<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编译学习资源</title>
    <url>/2023/05/09/%E7%BC%96%E8%AF%91%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>编译学习</p>
<span id="more"></span>

<h4 id="两本书"><a href="#两本书" class="headerlink" title="两本书"></a>两本书</h4><p>《深入理解计算机系统》（第三版）可以看。中英文都有电子书，看着玩。</p>
<p><a href="https://www.aliyundrive.com/s/bKVNaXMakYF">英文《深入理解计算机系统》</a></p>
<p><a href="https://www.aliyundrive.com/s/vDQCkVCdThz">中文《深入理解计算机系统》</a></p>
<p>《编译原理》（第二版），其实也就是龙书，偏原理，老师推荐我先写起来，自己写着玩玩。</p>
<p><a href="https://pan.baidu.com/s/1_xTFRTalGZc_XiGfW7ND2A?pwd=zhao">《编译原理》（第二版）</a></p>
<h4 id="三个网站"><a href="#三个网站" class="headerlink" title="三个网站"></a>三个网站</h4><p>①<a href="https://lotabout.me/2015/write-a-C-interpreter-0/">手把手教你构建 C 语言编译器</a></p>
<p>②<a href="https://space.bilibili.com/296494084/channel/collectiondetail?sid=571708">编译器B站视频</a></p>
<p>③<a href="https://github.com/rui314/chibicc/commits/main?before=90d1f7f199cc55b13c7fdb5839d1409806633fdb+315&branch=main&qualified_name=refs/heads/main">Commits · rui314&#x2F;chibicc (github.com)</a></p>
<p>④<a href="https://github.com/pihaoxuan/tiny_C_compiler">我自己写的，其实是模仿①，但是我加了很多注释，写法上也没那么难懂</a></p>
<p>END</p>
]]></content>
      <categories>
        <category>编译</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>一些git使用方法</title>
    <url>/2025/03/27/%E4%B8%80%E4%BA%9Bgit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一些git的使用方法（主要是<code>git push</code> 和 <code>pull</code> 之间的矛盾）</p>
<span id="more"></span>

<p>⚠⚠⚠</p>
<p>在多人协作开发中，自己在改代码的时候一定要先<code>git pull origin master</code>对远程仓库的代码进行最新版同步后再自己修改，避免在自己修改之后<code>push</code>不上去。（如果实在是忘记了，应该可以有命令解决，解决方法在下文）</p>
<h2 id="当pull代码时出现报错，描述为：本地代码有修改，git不知道怎么办，你打算："><a href="#当pull代码时出现报错，描述为：本地代码有修改，git不知道怎么办，你打算：" class="headerlink" title="当pull代码时出现报错，描述为：本地代码有修改，git不知道怎么办，你打算："></a>当<code>pull</code>代码时出现报错，描述为：本地代码有修改，<code>git</code>不知道怎么办，你打算：</h2><p><img src="/2025/03/27/%E4%B8%80%E4%BA%9Bgit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/%E5%BD%93%60pull%60%E4%BB%A3%E7%A0%81%E6%97%B6%E5%87%BA%E7%8E%B0%E6%8A%A5%E9%94%99%EF%BC%8C%E6%8F%8F%E8%BF%B0%E4%B8%BA%EF%BC%9A%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%9C%89%E4%BF%AE%E6%94%B9%EF%BC%8C%60git%60%E4%B8%8D%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E5%8A%9E.jpg" alt="当`pull`代码时出现报错，描述为：本地代码有修改，`git`不知道怎么办"></p>
<p>上图就是本地有修改后想<code>pull</code>远程仓库的代码下来，<code>git</code>的做法</p>
<h3 id="①放弃本地修改，直接照抄远程仓库代码"><a href="#①放弃本地修改，直接照抄远程仓库代码" class="headerlink" title="①放弃本地修改，直接照抄远程仓库代码"></a>①放弃本地修改，直接照抄远程仓库代码</h3><p>使用指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将本地的<code>HEAD</code>指针指向了上一个版本，删除了暂存区（暂存区就是<code>add</code>到的地方）的内容，而且还删除了本地工作区的内容。</p>
</blockquote>
<p>简单来说就是将本地的<code>add</code>和<code>commit</code>全部撤销，并且清空工作区的内容，像是将<code>git</code>恢复到了上一级的“出厂设置”。</p>
<p>执行指令后，就会看到类似于这样一段话</p>
<blockquote>
<p>HEAD is now at 上一版本号 上一版本<code>commit</code>内容</p>
</blockquote>
<p>这样就是成功了！</p>
<p>之后正常<code>pull</code>就能成功了，之后就会出现下图的反馈<br><img src="/2025/03/27/%E4%B8%80%E4%BA%9Bgit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/pull%E6%88%90%E5%8A%9F%E5%90%8E%E7%9A%84%E5%8F%8D%E9%A6%88.jpg" alt="`pull`成功后的反馈"></p>
<h3 id="②保留本地修改，不要远程仓库的修改（即以本地为准）"><a href="#②保留本地修改，不要远程仓库的修改（即以本地为准）" class="headerlink" title="②保留本地修改，不要远程仓库的修改（即以本地为准）"></a>②保留本地修改，不要远程仓库的修改（即以本地为准）</h3><h3 id="③合并两者的修改，并将其中冲突处人工检测解决冲突"><a href="#③合并两者的修改，并将其中冲突处人工检测解决冲突" class="headerlink" title="③合并两者的修改，并将其中冲突处人工检测解决冲突"></a>③合并两者的修改，并将其中冲突处人工检测解决冲突</h3><h2 id="git-add-指令"><a href="#git-add-指令" class="headerlink" title="git add  _____ 指令"></a><code>git add  _____</code> 指令</h2><p><code>git add .</code>：将所有 <strong>修改过的 新增的</strong> 文件添加到暂存区，但是不会管<strong>被删除的</strong>文件。</p>
<p><code>git add -u</code>：即<code>git add -update</code>，只管被监控了的文件，就是将已经被<code>add</code>了的文件（即暂存区的文件）如果有修改，就会更新。所以它<strong>不会管新文件</strong>，因为新文件没有被监控。会管<strong>修改过的</strong>和<strong>删除的</strong>文件。</p>
<p><code>git add -a</code>：即<code>git add -all</code>，是上面两个<code>git</code>的集合，会提交所有<strong>被删除</strong>、<strong>被修改</strong>、和<strong>新增的</strong>文件到数据暂存区</p>
<p>PS：如何查看自己项目目录下的文件的状态？</p>
<blockquote>
<p>使用<code>git status</code>命令就可以，下面复制</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>



<h2 id="当你使用commit指令的时候发现自己手瘸，打错字了，你选择："><a href="#当你使用commit指令的时候发现自己手瘸，打错字了，你选择：" class="headerlink" title="当你使用commit指令的时候发现自己手瘸，打错字了，你选择："></a>当你使用<code>commit</code>指令的时候发现自己手瘸，打错字了，你选择：</h2><p>①再次使用<code>git commit -m &quot;这次争取打对字&quot; </code>。</p>
<p>恭喜你，获得<strong>报错</strong>一次，欸嘿嘿。</p>
<blockquote>
<p>当第一次使用<code>commit</code>指令的时候，本地的<code>git</code>认为你提交了你的修改记录，所以此时你的工作区已经被清空了，因为你本地已经提交成功了，此时没有修改，没有再次<code>add</code>，是不会让你再次<code>commit</code>的</p>
</blockquote>
<p>②打开网址 <a href="https://pihaoxuan.github.io/2023/10/22/%E4%B8%80%E4%BA%9Bgit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">一些git使用方法 </a> 找方法</p>
<p>再次恭喜你，选对了方法！！！</p>
<blockquote>
<p><code>git reset --soft HEAD~1</code>指令：撤销提交并保留更改在暂存区（即回退到<code>add</code>完成之后）</p>
<p><code>git reset --mixed HEAD~1</code>指令：撤销提交并取消更改（即回退到<code>add</code>完成之前）</p>
<p><code>git reset --hard HEAD~1</code>指令： 撤销提交并<strong>删除</strong>所有更改（即回退到文件修改之前，未修改状态，或者说上一次提交完成后的状态）</p>
</blockquote>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次Ubuntu打包</title>
    <url>/2025/03/27/%E8%AE%B0%E4%B8%80%E6%AC%A1Ubuntu%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>记一次Ubuntu打包</p>
<p>前言：我的毕设是在Linux系统中开发一个对系统的全面检查软件，详情见网址<a href="https://gitee.com/pi_haoxuan/graduation-project">graduation-project: this is my graduation project</a> ，写完后，我就在研究如何将这个从Qt中剥离打包出来，于是，好事发生。。</p>
<span id="more"></span>

<p>Qt中正常运行测试看效果是将左下角的电脑图标调成debug模式，然后点击左下角的第一个绿色按钮，即可运行程序，此时在项目根目录的同级目录会生成<code>build-项目名称-Desktop_Qt版本_GCCxxx-Debug</code>的目录文件。如果想将开发好的软件发布，则需将运行模式由Debug模式改为Release模式，如下图所示：</p>
<p><img src="/2025/03/27/%E8%AE%B0%E4%B8%80%E6%AC%A1Ubuntu%E6%89%93%E5%8C%85/my-website\hexo\hexoblog\source_posts\记一次Ubuntu打包\1.jpg" alt="测试运行"></p>
<p>在Release模式下再次点击第一个绿色按钮，会经过一系列的长时间的编译，最后在项目根目录的同级目录会生成<code>build-项目名称-Desktop_Qt版本_GCCxxx-Release</code>的目录文件，其中就有编译好的二级制文件，在Release目录下执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./项目名称</span><br></pre></td></tr></table></figure>

<p>即可运行发布版本的APP。</p>
<p>但，这只是最基础的一步，这根本还没从Qt的环境中剥离出来，我想要的效果是一台刚装好的Linux机器也能运行，不需要再安装任何环境。接下来，继续打怪！</p>
<p>在一番调研下发现有个工具可以直接将文件打包，可高兴坏了，直呼Qt真是太贴心了！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install linuxdeployqt</span><br></pre></td></tr></table></figure>

<p>上述工具，顾名思义，就是在Linux系统下部署Qt应用的工具。</p>
<p>但是 我在执行上述命令时，遇到了错误[哭泣]，说是无法定位到这个包，于是我在网上狂找方法，但是找到最后发现，我已经安装了这个包，真的被自己蠢哭了[呜呜呜]。</p>
<p>接下来，继续打怪！</p>
<p>我高高兴兴地使用命令，开始打包【<strong>使用命令前，先将<code>Release</code>目录下的可执行文件先<code>cp</code>一份到任意新建的目录下然后在新建的目录下执行以下命令，为了方便描述，新建目录为与<code>Relese</code>目录同级的<code>new</code>目录</strong>】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linuxdeployqt 项目名称 -appimage</span><br></pre></td></tr></table></figure>

<p>但是，又出bug了，先是报两个ERROR说我的desktop文件和icon文件没有，然后自动给我建了这两类的default文件，网上一查发现这其实也不是什么大问题，按照编译的报错来说，最多算个warning。我以为这就结束了 ，但是，错误它又来了。</p>
<p>在它报了前两个所谓的ERROR后，又报了一个信息行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qmakePath 3= <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这次它没有加上ERROR:的前缀，正在我以为这是个无关紧要的Warning的时候，它竟然是是个fatal级的错误，于是我在查阅资料后，在上述命令后面显示指明了qmake的路径，即</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linuxdeployqt 项目名称 -appimage -qmake=/Qt安装路径/Qt版本号/gccxxx/bin/qmake</span><br></pre></td></tr></table></figure>

<p>具体的qmake路径因人而异，寻找路劲的方法👆</p>
<p>接下来，继续打怪！</p>
<p>解决完qmake路径问题后，我再次执行上述命令，满心欢喜等成功，果不其然，出意外了。</p>
<p>显示我的某个库not found，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR: ldd outputLine: <span class="string">&quot;libodbc.so.2 =&gt; not found&quot;</span></span><br><span class="line">ERROR: <span class="keyword">for</span> binary: <span class="string">&quot;/mnt/sdb/qt5/5.12.9/gcc_64/plugins/sqldrivers/libqsqlodbc.so&quot;</span></span><br><span class="line">ERROR: Please ensure that all libraries can be found by ldd. Aborting.</span><br></pre></td></tr></table></figure>

<p>我真的倦了，于是将其丢到deepseek中询问，它分析是因为ODBC的驱动库未安装（但为啥在Qt中可以运行呢？可能是Qt环境中包含？？），建议执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian系统执行</span></span><br><span class="line">sudo apt-get install unixodbc unixodbc-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS/RHEL系统执行</span></span><br><span class="line">sudo yum install unixODBC unixODBC-devel</span><br></pre></td></tr></table></figure>

<p>接下来，继续打怪！</p>
<p>我安装完了之后，它果然不报刚刚的错误了，我满心欢喜等成功，果不其然，出意外了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR: ldd outputLine: <span class="string">&quot;libpq.so.5 =&gt; not found&quot;</span></span><br><span class="line">ERROR: <span class="keyword">for</span> binary: <span class="string">&quot;/mnt/sdb/qt5/5.12.9/gcc_64/plugins/sqldrivers/libqsqlpsql.so&quot;</span></span><br><span class="line">ERROR: Please ensure that all libraries can be found by ldd. Aborting.</span><br></pre></td></tr></table></figure>

<p>照猫画虎，我已经有deepseek这个得力助将了，于是deepseek建议我安装以下库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian系统安装</span></span><br><span class="line">sudo apt-get install libpq5</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS/RHEL系统安装</span></span><br><span class="line">sudo yum install postgresql-libs</span><br></pre></td></tr></table></figure>

<p><strong>TIPS：出现类似库找不到的问题，大可以直接丢给DeepSeek，按照它的建议安装库即可</strong></p>
<p>接下来，继续打怪！</p>
<p>我安装完了之后，它果然不报刚刚的错误了，我满心欢喜等成功，果不其然，成功了！！！</p>
<p>虽然也报了一些信息行，但是都是小问题，如下图，一般都是成功了。【再次吐槽，有些fatal和有些Error实际上只是Warning，有些不起眼的信息竟然是fatal】</p>
<p><img src="/2025/03/27/%E8%AE%B0%E4%B8%80%E6%AC%A1Ubuntu%E6%89%93%E5%8C%85/my-website\hexo\hexoblog\source_posts\记一次Ubuntu打包\2.jpg" alt="linuxdeployqt成功"></p>
<p>在<code>new</code>目录下执行完上述命令后，就会出现一些文件【上图我还是在Release目录下执行的，显然是个憨批，各位读者大佬不要学他】</p>
<p><img src="/2025/03/27/%E8%AE%B0%E4%B8%80%E6%AC%A1Ubuntu%E6%89%93%E5%8C%85/my-website\hexo\hexoblog\source_posts\记一次Ubuntu打包\3.jpg" alt="出现的文件"></p>
<p>其中<code>AppRun</code>是个链接文件，<code>default.desktop</code>和<code>default.png</code>是上述说的报错默认新建的文件等。</p>
<p>接下来，继续打怪！</p>
<p>完成之后，在你喜欢的目录下用你喜欢的名字建一个目录（推荐家目录），在里面建两个文件夹：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ./DEBIAN</span><br><span class="line"><span class="built_in">mkdir</span> -p ./usr/src</span><br></pre></td></tr></table></figure>

<p>将<code>new</code>文件夹中的文件全部copy到src中【为啥我的这个*看起来跟一朵花一样】：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> new的上级目录/new/* 你喜欢的目录/usr/src</span><br></pre></td></tr></table></figure>

<p>回到同时装有<code>DEBIAN</code>和<code>usr</code>的目录下，也就是你建的你喜欢的目录下，</p>
<p>在<code>DEBIAN</code>目录下建立一个文件<code>control</code>【这个应该不用命令示范了】</p>
<p>在<code>control</code>文件中写以下内容【仅示例，不准确】：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Package: mytest</span><br><span class="line">Version: 0.1.0</span><br><span class="line">Section: utils</span><br><span class="line">Priority: optional</span><br><span class="line">Architecture: amd64</span><br><span class="line">Depends:</span><br><span class="line">Installed-Size: 512</span><br><span class="line">Maintainer: 123@163.com</span><br><span class="line">Description: my test package</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/zhaominyong/article/details/139021721">control文件具体参考</a></p>
<p>control文件搞定后，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -b . 软件名称.deb</span><br></pre></td></tr></table></figure>

<p>就会发现在与<code>DEBIAN</code>目录同级中奇迹般地出现了一个<code>项目名称.deb</code>的包，果不其然，成功了！</p>
<p>可以快乐地使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i 软件名称.deb</span><br></pre></td></tr></table></figure>

<p>就可以安装软件了，以下给出卸载命令，其余命令可以请教互联网其它文章，嘻嘻。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -r packageName</span><br></pre></td></tr></table></figure>

<p>其中<code>packageName</code>即为<code>DEBIAN</code>目录下<code>control</code>文件中的第一项，且不分大小写，如果你<code>control</code>文件中是大写，卸载时也需要写小写，不然会报错找不到或系统没安装。</p>
<p>END</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Ubuntu不能输入中文问题</title>
    <url>/2024/12/30/%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>解决Ubuntu不能输入中文问题</p>
<span id="more"></span>
<p>最近在使用Ubuntu部署MaxKB。部署成功后，在测试MaxKB的问答机器人时，想输入中文问题，但是发现不论怎么切换输入法都不能输入中文。如下图：<br><img src="/2024/12/30/%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/1.jpg" alt="问题"></p>
<ol>
<li>先检查区域和语言是否有问题，发现区域和语言都没问题，如下图：<br><img src="/2024/12/30/%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/2.jpg" alt="检查区域和语言"></li>
<li>尝试使用<code>ibus-setup</code>命令设置，发现输入法里面是空的，如下图：<br><img src="/2024/12/30/%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/3.jpg" alt="ibus-setup"><br>于是我在里面添加了一个中文输入法。添加步骤如下：<ol>
<li>点击添加，选择<code>中文</code>，然后选择<code>中文-智能拼音</code>，添加好了之后可以直接关闭，如下图：<br><img src="/2024/12/30/%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/4.jpg" alt="添加中文输入法"></li>
<li>返回到<code>设置-区域与语言</code>，点击<code>输入源</code>选项下的加号➕，选择<code>汉语</code>然后选择<code>中文(智能拼音)</code>，然后点击<code>添加</code>，并将其按住拖动到第一个位置，如下图：<br><img src="/2024/12/30/%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/5.jpg" alt="设置中添加输入源"></li>
<li>完成以上步骤之后就可以将设置关闭，然后在右上角将输入法切换到<code>中</code>字样的输入法，即可正常输入中文，如下图：<br><img src="/2024/12/30/%E8%A7%A3%E5%86%B3Ubuntu%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/6.jpg" alt="正常输入中文"></li>
</ol>
</li>
</ol>
<p>END</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>20240416小教-人工智能</title>
    <url>/2024/04/15/20240416%E5%B0%8F%E6%95%99-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
    <content><![CDATA[<p>NLP and digital Image Processing</p>
<span id="more"></span>

<p>以下是上课用到的课件及工具，请有需要的同学自行下载</p>
<p>python环境：<a href="https://pihaoxuan.github.io/2023/06/21/python/">点我打开页面</a></p>
<p>课件有点大（1GB+）</p>
<p><a href="https://pan.baidu.com/s/1HZsaI1JfMdpWDWMyBAo8eg?pwd=zhao">点我下载课件</a></p>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>course</tag>
      </tags>
  </entry>
  <entry>
    <title>助班助理面试简历</title>
    <url>/2024/04/15/%E5%8A%A9%E7%8F%AD%E5%8A%A9%E7%90%86%E9%9D%A2%E8%AF%95%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<p>助班助理面试简历</p>
<span id="more"></span>

<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile2.0/%E6%9D%A8%E6%8C%AF%E5%AE%81%E5%88%9B%E6%96%B0%E7%8F%AD%E5%8A%9E%E5%85%AC%E5%AE%A4%E5%8A%A9%E7%90%86%E7%AE%80%E5%8E%86.docx">杨振宁创新班助理简历模板</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile2.0/%E6%9D%A8%E6%8C%AF%E5%AE%81%E5%88%9B%E6%96%B0%E7%8F%AD%E5%8A%A9%E7%90%86%E7%8F%AD%E4%B8%BB%E4%BB%BB%E7%AE%80%E5%8E%86.docx">杨振宁创新班2024级助班简历模板</a></p>
]]></content>
      <categories>
        <category>文件下载</category>
      </categories>
      <tags>
        <tag>文件下载</tag>
      </tags>
  </entry>
  <entry>
    <title>科学必经之路</title>
    <url>/2024/04/07/%E6%9C%BA%E5%9C%BA/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4cd11aea6b30a5e0adc0afa3d03ea343a8607e6b35d1272387c0a42dc6b6ad6e">4630436162ade97ba2718b7d0c4b3b63613450f94e5b0e42cf52d6ac860fb8794780d51908975058790d2887adf3835850c2afbecbca1f833ebb279d83e2f73b39e4cbc057a217d9a3f8008116d8432e1a22d70e95280456e36a1c03aca46e45f2509b2f80e5b717cbc09d348751cabd2de8946e223b009bfead8bc802b1f3f427fc76112e5b315728eabd57a539a3dfeac61ccdfb924127b66f70928eefef3aa22b9289eeb4a62506188c86714c043d3fcd7299a445ae0a9cd994ef4a6e4b03b138ebef1c321ef734ac2d236a1c58bed87002df21c4d9ad7b4645c9dcc8af54281db2dd725a11970002f3d7390e636097af3801ebaa3b0fbac58ac5f6787ad68818c72c53e3e01ba8b99869253cf25acc0f86858b0fcfb402325620394512184bfe07d023304e6e6041c87b50d67f5b776fc669de824222f1d38529bdadd5acc2cb10da49727b75eb19ca152059f80140583ee2a901009647af9edb2b754b4d575cbf07ee1cb3f4282fb4e1fa073dc62bbfeb09e6761cc26e8aa70f8ef7ae896076c95e38560552187f26c968a306a65036633951fc04aa89f7fb02f240274bc320a16429e84420162ef035bc63744f588ae20923ccfdf459216d6a43132f05d07c1019379817ce73a18b086528825a5c64e07e12bf1911a5cacc88815ee308f1adc30e857982fdcbfdfa8306a6c27c5db0839a17d7d45c0cbb55c0ce90cd2a815b7473dd05e3948cec1570a1777589553113c743ca4c09f0287b6eb55029839b313862dc3ac2b886c684a2a8e6579af6d1ed413a80ee8577a6a27d76a6665c3b2763d31aa9ff63db696141f689887938abe0cfbd0f76866779dd6c665c6dc27f751911b6454a9d33ac18512aab6f15337027f5b3e96baeaa433c52949d600e9e4e872af5b1d3914af3abe48f39fd9af71e4c3ed1b3f06132cca029a70db7382201340349ac089903c525bbd0ddc387b1414eb88407332331ab6950988ddc5b88a01e148d34021bd33748096b615ffef9f1064e612848a16a5160a7041771aa45211195d04544700c8a855eb1c64b44e7c4b4e97c3e3c5701a83ef0e93fca877c7bf69a72933243d7876c0325ae50c70a94192c533fd99c83483eb6ec9d3f2e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令大全</title>
    <url>/2024/03/22/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><code>git</code> command and some explains</p>
<span id="more"></span>

<h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a><code>git init</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init (newDir)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在当前目录初始化一个<code>git</code>仓库或者重新初始化一个已经存在的仓库。执行完之后会在当前目录下生成一个<code>.git</code>目录（Windows下可能设置了隐藏的项目不可见，设置一下就好了。<a href="https://support.microsoft.com/zh-cn/windows/%E5%9C%A8-windows-%E4%B8%AD%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9-97fbc472-c603-9d90-91d0-1166d1d9f4b5">Windows下显示隐藏项目</a>）</p>
</blockquote>
<blockquote>
<p><code>Linux</code>下在命令行界面运行命令<code>la</code>即可看到。</p>
</blockquote>
<blockquote>
<p>括号中的<code>newDir</code>可以选择是否添加。</p>
<p>如果添加，则在初始化的过程中还会在当前目录下，新建一个子目录<code>newDir</code>。</p>
</blockquote>
<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a><code>git clone</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;URL&gt; [your_dir]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从URL网站上克隆（完全复制）项目到本地<strong>（可以不用加入这个项目仓库）</strong>。<code>your_dir</code>为可选参数，如果选择，则克隆到指定目录<code>your_dir</code>，如果不选择，则默认克隆到当前目录。</p>
</blockquote>
<h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a><code>git config</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global uesr.name [&quot;your_name&quot;]</span><br><span class="line">git config --global user.email [&quot;your_email&quot;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置<code>git</code>用户信息，包括邮箱，用户名。用于辨识提交项目的人。**<code>gitee</code>不会对用户名和邮箱进行验证，即便你的邮箱和用户名是假的**，如果邮箱存在，则在项目中显示某内容为该邮箱提交的，如果邮箱无效，则显示某内容是该用户名提交的。</p>
</blockquote>
<blockquote>
<p>如果不选择中括号内的参数，则只表示查询。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br><span class="line">git config --global --edit</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以查看全局配置信息，包括配置的用户名，邮箱，已配置<code>git</code>的路径等</p>
<p>第二个命令是默认用打开<code>vim</code>打开配置信息文件：<a href="https://blog.csdn.net/wangyuxiang946/article/details/126560108">vim使用方法</a>。</p>
</blockquote>
<h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status [-s]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看当前目录下文件跟踪<strong>状态</strong></p>
</blockquote>
<blockquote>
<p>若使用可选参数，则在被跟踪文件左边出现说明</p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">M:被修改的文件</span><br><span class="line">A:新添加的文件</span><br><span class="line">D:被删除的文件</span><br><span class="line">R:重命名的文件</span><br><span class="line">??:未被跟踪的文件</span><br></pre></td></tr></table></figure>

<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a><code>git diff</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff</span><br><span class="line">git diff --cached</span><br><span class="line">git diff HEAD</span><br><span class="line">git diff your_file</span><br><span class="line">git diff --stat</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>git diff</code>查看还没有被缓存的改动</p>
<p><code>git diff --cached</code>查看已经被缓存的改动</p>
<p><code>git diff HEAD</code>查看已经缓存和未缓存的所有改动</p>
<p><code>git diff your_file</code>查看某个文件的改动</p>
<p><code>git diff --stat</code>查看摘要而非改动细节</p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>digitalImageProcessing-lab4</title>
    <url>/2023/12/14/digitalImageProcessing-lab4/</url>
    <content><![CDATA[<p>Roberts算子边缘检测、Sobel算子边缘检测、Prewitt算子边缘检测、拉普拉斯算子边缘检测</p>
<span id="more"></span>

<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>掌握基本边缘检测算法</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>Roberts算子边缘检测</li>
<li>Sobel算子边缘检测</li>
<li>Prewitt算子边缘检测</li>
<li>拉普拉斯算子边缘检测（由于拉普拉斯算子检测过暗，本实验换为高斯-拉普拉斯算子）</li>
</ol>
<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><ol>
<li><p>Roberts算子边缘检测<br><img src="/2023/12/14/digitalImageProcessing-lab4/image.png" alt="Alt text"><br><strong>算法分析：</strong><br>Roberts算子的模板分为水平方向和垂直方向，如上图所示，从其模板可以看出，Roberts算子能较好的增强正负45度的图像边缘。根据上图可以得出下面算法：<br>图中某点经过罗伯特交叉梯度算子边缘检测后，获得响应主要依赖于对角上写的像素值$ f(\text右下角)-f(\text左上角) $ 或者是 $f(\text左下角) - f(\text右上角)$，即左边图对负45°为0响应，右边图对正45°为0响应，两图合并实现对正负45°边缘的检测。</p>
</li>
<li><p>Prewitt算子边缘检测<br><img src="/2023/12/14/digitalImageProcessing-lab4/image-2.png" alt="Alt text"><br><strong>算法分析：</strong><br>Prewitt算子边缘检测利用两个卷积核（一个用于水平方向，一个用于垂直方向)分别对图像进行卷积，然后通过求两个方向的梯度幅值和方向来检测边缘。<br>Prewitt算子对边缘的响应比较敏感，但也容易受到噪声的影响。<br>Prewitt算子的卷积核对边缘的响应较为敏感，是因为卷积核中的权重值对边缘的梯度有较强的反应，也正是因为这个，卷积核中的权重也对图像中的噪声敏感，当图像受到噪声的影响时，Prewitt算子可能会放大噪声，导致在边缘以外的区域产生较强的响应。</p>
</li>
<li><p>Sobel算子边缘检测<br><img src="/2023/12/14/digitalImageProcessing-lab4/image-1.png" alt="Alt text"><br><strong>算法分析：</strong><br>Sobel算子类似于Prewitt算子，也是通过两个卷积核（一个用于水平方向，一个用于垂直方向）来计算梯度。<br>但是Sobel算子在距离中心像素点较近的四个点位（上下左右)采取了较其他像素点双倍权重的方法，使得靠近中心像素点的点占比更大，能有效较低较远处的噪声的影响。也就是在一定程度上能够让图片降噪，使得结果更加精确真实。</p>
</li>
<li><p>拉普拉斯算子边缘检测以及高斯拉普拉斯算子边缘检测<br>拉普拉斯算子：<img src="/2023/12/14/digitalImageProcessing-lab4/image-3.png" alt="Alt text"><br><strong>算法分析：</strong><br>对于拉普拉斯算子边缘检测，如果结果 &lt; 0，说明滤波中心是局部极大值，可能是噪声点，也可能是边缘上的点；结果 &#x3D; 0，说明滤波中心很可能处于平坦区域；结果 &gt; 0，说明滤波中心是局部极小值，可能是噪声点，也可能是边缘。<br>即拉普拉斯算子对含有噪声的图像极容易检测出假边缘，从而对噪点做出高响应。<br>于是引入高斯拉普拉斯算子边缘检测</p>
<br></li>
</ol>
<p>高斯拉普拉斯算子：<img src="/2023/12/14/digitalImageProcessing-lab4/image-4.png" alt="Alt text"><br><strong>算法分析：</strong><br>先对有噪声的图像高斯平滑处理，然后再使用拉普拉斯算子进行边缘检测，也可以将两个步骤 集成在如上图所示的一个卷积核中处理。。<br>在图像中，平坦的区域的拉普拉斯响应为0， 在边缘处的响应值较为剧烈，可以检测边缘的存在。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="comment"># 读取图片</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">image, file_path</span>):</span><br><span class="line">    <span class="comment"># 保存图片</span></span><br><span class="line">    image.save(file_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_image</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 显示图片</span></span><br><span class="line">    image.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">roberts_operator</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># Roberts算子边缘检测</span></span><br><span class="line">    width, height = image.size</span><br><span class="line">    result_pixels = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width - <span class="number">1</span>):</span><br><span class="line">            pixel1 = image.getpixel((x, y))</span><br><span class="line">            pixel2 = image.getpixel((x + <span class="number">1</span>, y + <span class="number">1</span>))</span><br><span class="line">            pixel3 = image.getpixel((x+ <span class="number">1</span> ,y))</span><br><span class="line">            pixel4 = image.getpixel((x,y + <span class="number">1</span>))</span><br><span class="line">            <span class="comment"># 边缘处理</span></span><br><span class="line">            <span class="keyword">if</span>(x+<span class="number">1</span>&gt;=width):</span><br><span class="line">                pixel2 = <span class="number">0</span></span><br><span class="line">                pixel3 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span>(y+<span class="number">1</span>&gt;=height):</span><br><span class="line">                pixel2 = <span class="number">0</span></span><br><span class="line">                pixel4 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用Roberts算子进行边缘检测</span></span><br><span class="line">            gradient1 = <span class="built_in">abs</span>(pixel1 - pixel2)</span><br><span class="line">            gradient2 = <span class="built_in">abs</span>(pixel3-pixel4)</span><br><span class="line">            gradient = sqrt(<span class="built_in">pow</span>(gradient1,<span class="number">2</span>)+<span class="built_in">pow</span>(gradient2,<span class="number">2</span>))</span><br><span class="line">            </span><br><span class="line">            result_pixels.append(gradient)</span><br><span class="line"></span><br><span class="line">    result_image = Image.new(<span class="string">&quot;L&quot;</span>, (width - <span class="number">1</span>, height - <span class="number">1</span>))</span><br><span class="line">    result_image.putdata(result_pixels)</span><br><span class="line">    <span class="keyword">return</span> result_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sobel_operator</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># Sobel算子边缘检测</span></span><br><span class="line">    width, height = image.size</span><br><span class="line">    result_pixels = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, height - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, width - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># Sobel算子权重</span></span><br><span class="line">            weights1 = [</span><br><span class="line">                [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">                [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">            ]</span><br><span class="line">            weights2 = [</span><br><span class="line">                [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">            ]</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算Sobel算子的梯度</span></span><br><span class="line">            gradient1 = <span class="built_in">sum</span>(<span class="built_in">sum</span>(weights1[i][j] * image.getpixel((x + j - <span class="number">1</span>, y + i - <span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">            gradient2 = <span class="built_in">sum</span>(<span class="built_in">sum</span>(weights2[i][j] * image.getpixel((x + j - <span class="number">1</span>, y + i - <span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">            gradient = sqrt(<span class="built_in">pow</span>(gradient1,<span class="number">2</span>)+<span class="built_in">pow</span>(gradient2,<span class="number">2</span>))</span><br><span class="line">            </span><br><span class="line">            result_pixels.append(<span class="built_in">abs</span>(gradient))</span><br><span class="line"></span><br><span class="line">    result_image = Image.new(<span class="string">&quot;L&quot;</span>, (width - <span class="number">2</span>, height - <span class="number">2</span>))</span><br><span class="line">    result_image.putdata(result_pixels)</span><br><span class="line">    <span class="keyword">return</span> result_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prewitt_operator</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># Prewitt算子边缘检测</span></span><br><span class="line">    width, height = image.size</span><br><span class="line">    result_pixels = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, height - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, width - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># Prewitt算子权重</span></span><br><span class="line">            weights1 = [</span><br><span class="line">                [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">            ]</span><br><span class="line">            weights2 = [</span><br><span class="line">                [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算Prewitt算子的梯度</span></span><br><span class="line">            gradient1 = <span class="built_in">sum</span>(<span class="built_in">sum</span>(weights1[i][j] * image.getpixel((x + j - <span class="number">1</span>, y + i - <span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">            gradient2 = <span class="built_in">sum</span>(<span class="built_in">sum</span>(weights2[i][j] * image.getpixel((x + j - <span class="number">1</span>, y + i - <span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">            gradient = sqrt(<span class="built_in">pow</span>(gradient1,<span class="number">2</span>)+<span class="built_in">pow</span>(gradient2,<span class="number">2</span>))</span><br><span class="line">            result_pixels.append(<span class="built_in">abs</span>(gradient))</span><br><span class="line"></span><br><span class="line">    result_image = Image.new(<span class="string">&quot;L&quot;</span>, (width - <span class="number">2</span>, height - <span class="number">2</span>))</span><br><span class="line">    result_image.putdata(result_pixels)</span><br><span class="line">    <span class="keyword">return</span> result_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">laplacian_operator</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 拉普拉斯算子边缘检测</span></span><br><span class="line">    width, height = image.size</span><br><span class="line">    result_pixels = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, height - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, width - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 拉普拉斯算子权重</span></span><br><span class="line">            weights = [</span><br><span class="line">                [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>, -<span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">            ]</span><br><span class="line">            weights2 = [</span><br><span class="line">                [<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                [-<span class="number">1</span>,-<span class="number">2</span>,<span class="number">17</span>,-<span class="number">2</span>,-<span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">           ]</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算拉普拉斯算子的梯度</span></span><br><span class="line">            <span class="comment"># gradient = sum(sum(weights[i][j] * image.getpixel((x + j - 1, y + i - 1)) for j in range(3)) for i in range(3))</span></span><br><span class="line">            <span class="comment"># 高斯拉普拉斯算子</span></span><br><span class="line">            gradient = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">                temp = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">                    <span class="keyword">if</span>(x+j-<span class="number">2</span>&gt;=width <span class="keyword">or</span> x+j-<span class="number">2</span>&lt;<span class="number">0</span> <span class="keyword">or</span> y+i-<span class="number">2</span>&gt;=height <span class="keyword">or</span> y+i-<span class="number">2</span>&lt;<span class="number">0</span>):</span><br><span class="line">                        pixel1 = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pixel1 = image.getpixel((x + j - <span class="number">2</span>, y + i - <span class="number">2</span>))</span><br><span class="line">                    temp += weights2[i][j] * pixel1</span><br><span class="line">                gradient  +=temp   </span><br><span class="line">                    </span><br><span class="line">                        </span><br><span class="line">            <span class="comment"># gradient = sum(sum(weights2[i][j] * image.getpixel((x + j - 2, y + i - 2)) for j in range(5)) for i in range(5))</span></span><br><span class="line"></span><br><span class="line">            result_pixels.append(<span class="built_in">abs</span>(gradient))</span><br><span class="line"></span><br><span class="line">    result_image = Image.new(<span class="string">&quot;L&quot;</span>, (width - <span class="number">2</span>, height - <span class="number">2</span>))</span><br><span class="line">    result_image.putdata(result_pixels)</span><br><span class="line">    <span class="keyword">return</span> result_image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    dir_path = <span class="string">&quot;./img3/&quot;</span></span><br><span class="line">    <span class="comment"># 读取图片</span></span><br><span class="line">    input_image = read_image(dir_path+<span class="string">&quot;img3.tif&quot;</span>)</span><br><span class="line">    display_image(input_image)</span><br><span class="line">    kernel_size = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Roberts算子边缘检测</span></span><br><span class="line">    roberts_result = roberts_operator(input_image)</span><br><span class="line">    save_image(roberts_result, dir_path+<span class="string">&quot;robert.bmp&quot;</span>)</span><br><span class="line">    display_image(roberts_result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sobel算子边缘检测</span></span><br><span class="line">    sobel_result = sobel_operator(input_image)</span><br><span class="line">    save_image(sobel_result, dir_path+<span class="string">&quot;sobel.bmp&quot;</span>)</span><br><span class="line">    display_image(sobel_result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prewitt算子边缘检测</span></span><br><span class="line">    prewitt_result = prewitt_operator(input_image)</span><br><span class="line">    save_image(prewitt_result, dir_path+<span class="string">&quot;prewitt.bmp&quot;</span>)</span><br><span class="line">    display_image(prewitt_result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拉普拉斯算子边缘检测</span></span><br><span class="line">    midValue_result = midValue(inpunt_image,kernel_size)</span><br><span class="line">    display_image(midValue_result)</span><br><span class="line">    laplacian_result = laplacian_operator(input_image)</span><br><span class="line">    display_image(laplacian_result)</span><br><span class="line">    save_image(laplacian_result, dir_path+<span class="string">&quot;laplacian_gaosi_result.bmp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>对于图一：</p>
<div style="display: flex; flex-wrap: wrap; justify-content: center;">
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img1/robert.bmp" alt="bright" style="zoom: 70%;">
    <p><em>Image 1: robert_result</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img1/prewitt.bmp" alt="bright" style="zoom: 70%;">
    <p><em>Image 2: prewitt_result</em></p>
  </div>
  </div>
<div style="display: flex; flex-wrap: wrap; justify-content: center;">
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img1/sobel.bmp" alt="bright" style="zoom: 70%;">
    <p><em>Image 3: sobel_result</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img1/laplacian_gaosi_result.bmp" alt="bright" style="zoom: 70%;">
    <p><em>Image 4:LoG_result</em></p>
  </div>
  </div>





















<p>对于图二：</p>
<div style="display: flex; flex-wrap: wrap; justify-content: center;">
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img2/robert.bmp" alt="bright" style="zoom: 55%;">
    <p><em>Image 5: robert_result</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img2/prewitt.bmp" alt="bright" style="zoom: 55%;">
    <p><em>Image 6: prewitt_result</em></p>
  </div>
  </div>
<div style="display: flex; flex-wrap: wrap; justify-content: center;">
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img2/sobel.bmp" alt="bright" style="zoom: 55%;">
    <p><em>Image 7: sobel_result</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img2/laplacian_gaosi_result.bmp" alt="bright" style="zoom: 55%;">
    <p><em>Image 8:LoG_result</em></p>
  </div>
  </div>

























<p>对于图三：</p>
<div style="display: flex; flex-wrap: wrap; justify-content: center;">
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img3/robert.bmp" alt="bright" style="zoom: 45%;">
    <p><em>Image 9: robert_result</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img3/prewitt.bmp" alt="bright" style="zoom: 45%;">
    <p><em>Image 10: prewitt_result</em></p>
  </div>
  </div>
<div style="display: flex; flex-wrap: wrap; justify-content: center;">
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img3/sobel.bmp" alt="bright" style="zoom: 45%;">
    <p><em>Image 11: sobel_result</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img3/laplacian_gaosi_result.bmp" alt="bright" style="zoom: 45%;">
    <p><em>Image 12:LoG_result</em></p>
  </div>
  </div>



















<p> 对于图四：</p>
  <div style="display: flex; flex-wrap: wrap; justify-content: center;">
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img4/robert.bmp" alt="bright" style="zoom: 20%;">
    <p><em>Image 13: robert_result</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img4/prewitt.bmp" alt="bright" style="zoom: 20%;">
    <p><em>Image 14: prewitt_result</em></p>
  </div>
  </div>
<div style="display: flex; flex-wrap: wrap; justify-content: center;">
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img4/sobel.bmp" alt="bright" style="zoom: 20%;">
    <p><em>Image 15: sobel_result</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/14/digitalImageProcessing-lab4/img4/laplacian_gaosi_result.bmp" alt="bright" style="zoom: 20%;">
    <p><em>Image 16:LoG_result</em></p>
  </div>
  </div>



<h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><h4 id="对于图一："><a href="#对于图一：" class="headerlink" title="对于图一："></a>对于图一：</h4><p>robert算子边缘检测模板大小只有$2×2$大小，对于原图而言，可能会损失一些细节，从而使图一的robert算子检测出来的图像看起来过暗，看不到太多细节，其次，由于该算子对于水平或者垂直的边缘响应不是很剧烈，也容易丢弃一些细节，是图片看起来过于简单。</p>
<p>prewitt算子边缘检测的算子相对于robert算子所囊括的面积更大，能够保留更多的细节，所以图片看起来细节增多，一些较为不明显的边缘也能够被检测出来。</p>
<p>soobel算子相较于prewitt算子加大了中间部分的权重，使得更加突出边缘，所以图一的soobel算子检测结果比prewitt算子的边缘更加明显，更加明亮。</p>
<p>拉普拉斯算子由于对噪声过于敏感，将边缘信息覆盖，使得拉普拉斯算子检测出来的结果如下图所示<br><img src="/2023/12/14/digitalImageProcessing-lab4/img1/laplacian.bmp"><br>几乎看不见检测出来的边缘。<br>于是用高斯拉普拉斯算子检测得出如下结果：<br><img src="/2023/12/14/digitalImageProcessing-lab4/img1/laplacian_gaosi_result.bmp"><br>此结果相较于单纯的拉普拉斯算子边缘检测较好，但是还是收到噪声影响，损失了过多的细节，只能看到些许轮廓。</p>
<h4 id="对于图二："><a href="#对于图二：" class="headerlink" title="对于图二："></a>对于图二：</h4><p>robert算子同样因为卷积核过小，不能体现细节部分，只有大概的轮廓，即月亮的最边缘部分，月球表面上的边缘并不是很明显</p>
<p>prewitt算子相较于robert算子的卷积核较为复杂，能保存的月球表面的细节更多</p>
<p>sobel算子在prewitt算子的基础上增加了核心像素周围的权重，使得核心像素占比更大，边缘突出明显</p>
<p>拉普拉斯算子由于受噪声影响太大，检测结果如图：<br><img src="/2023/12/14/digitalImageProcessing-lab4/img2/laplacian_result.bmp"><br>上图所见几乎看不清月球表面的边缘细节，于是换成高斯拉普拉斯边缘检测<br><img src="/2023/12/14/digitalImageProcessing-lab4/img2/laplacian_gaosi_result.bmp"><br>可以看出边缘明显增强，但是由于噪声影响依旧在，没有完全消除，导致假边缘出现过多。</p>
<h4 id="对于图三："><a href="#对于图三：" class="headerlink" title="对于图三："></a>对于图三：</h4><p>robert算子同样因为卷积核过小，不能体现细节部分，只有大概的轮廓，即建筑物的最边缘部分，建筑物上的边缘细节并不是很明显</p>
<p>prewitt算子相较于robert算子的卷积核较为复杂，能保存表面的细节更多</p>
<p>sobel算子在prewitt算子的基础上增加了核心像素周围的权重，使得核心像素占比更大，边缘突出明显，也增多了一些边缘细节</p>
<p>拉普拉斯算子边缘检测由于受噪声影响，检测结果如下图：<br><img src="/2023/12/14/digitalImageProcessing-lab4/img3/laplacian_result.bmp"><br>可以看出，只有较为明显的边缘能检测出来，并且检测出的结果也很模糊，受噪声影响过大<br>换用高斯拉普拉斯算子检测得到结果如下：<br><img src="/2023/12/14/digitalImageProcessing-lab4/img3/laplacian_gaosi_result.bmp"><br>也能看出噪声污染严重，但是能检测出一些细节部分，相较于原拉普拉斯算子效果变好</p>
<h4 id="对于图四："><a href="#对于图四：" class="headerlink" title="对于图四："></a>对于图四：</h4><p>robert算子同样因为卷积核过小，不能体现细节部分，只有大概的轮廓。且robert算子对于水平和垂直部分检测效果不是很好，从图中可以看出房子的垂直的边缘检测效果不好，几乎检测不出房子的垂直边缘和水平边缘，最明显的就是倾斜边缘。</p>
<p>prewitt算子相较于robert算子的卷积核较为复杂，能保存表面的细节更多，并且其垂直边缘和水平边缘明显强于robert算子检测结果。</p>
<p>sobel算子在prewitt算子的基础上增加了核心像素周围的权重，使得核心像素占比更大，边缘突出明显</p>
<p>拉普拉斯算子因为对噪声过于敏感，检测出的图像几乎都是很明显的边缘，对于房子墙体的边缘则没有过大响应<br><img src="/2023/12/14/digitalImageProcessing-lab4/img4/laplacian_result.bmp"><br>于是改用高斯拉普拉斯算子检测，结果如图：<br><img src="/2023/12/14/digitalImageProcessing-lab4/img4/laplacian_gaosi_result.bmp"><br>上图虽然对墙体的边缘有了较大的响应，但是整体有过重的噪声污染，较拉普拉斯算子检测效果好。</p>
<p><a href="https://pihaoxuan.github.io/2023/12/14/digitalImageProcessing-lab4/lab4.pdf">pdf preview</a></p>
<div class="pdfobject-container" data-target="https://pihaoxuan.github.io/2023/12/14/digitalImageProcessing-lab4/lab4.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>digitalImageProcessing-lab3</title>
    <url>/2023/12/07/digitalImageProcessing-lab3/</url>
    <content><![CDATA[<p>实验三：拉普拉斯变换、变体拉普拉斯变换、高斯-拉普拉斯变换</p>
<span id="more"></span>

<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>掌握基于拉普拉斯变换的图像锐化算法</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>基本拉普拉斯变换图像增强<br>拉普拉斯变体变换图像增强<br>高斯-拉普拉斯变换图像增强</p>
<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h4 id="基本拉普拉斯变换图像增强"><a href="#基本拉普拉斯变换图像增强" class="headerlink" title="基本拉普拉斯变换图像增强"></a>基本拉普拉斯变换图像增强</h4><p>基于以下卷积核模板的图像变换<br><img src="/2023/12/07/digitalImageProcessing-lab3/image.png" alt="Alt text"></p>
<h4 id="拉普拉斯变体变换图像增强"><a href="#拉普拉斯变体变换图像增强" class="headerlink" title="拉普拉斯变体变换图像增强"></a>拉普拉斯变体变换图像增强</h4><p>基于以下卷积核模板的图像变换<br><img src="/2023/12/07/digitalImageProcessing-lab3/image-1.png" alt="Alt text"></p>
<h4 id="高斯-拉普拉斯变换图像增强"><a href="#高斯-拉普拉斯变换图像增强" class="headerlink" title="高斯-拉普拉斯变换图像增强"></a>高斯-拉普拉斯变换图像增强</h4><p>基于以下卷积核模板的图像变换<br><img src="/2023/12/07/digitalImageProcessing-lab3/image-2.png" alt="Alt text"></p>
<h3 id="算法解释说明"><a href="#算法解释说明" class="headerlink" title="算法解释说明"></a>算法解释说明</h3><p><strong>基本原理</strong></p>
<p>以模板<img src="/2023/12/07/digitalImageProcessing-lab3/image-3.png" alt="Alt text">为例，用$g(x,y)$代表变换后的像素值，$f(x,y)$代表变换前的像素值，则有如下公示：<br>$g(x,y) &#x3D; -4 × f(x,y) + [f(\text{上})+f(\text{下})+f(\text{左})+f(\text{右})]$<br>如果该区域为平坦区域，则 $g(x,y)$ 结果为0，即对平坦区域实现0响应。<br>如果该区域为边缘，则在$[f(\text{上})、f(\text{下})、f(\text{左})、f(\text{右})]$中有一个与其它像素值不同，那么$g(x,y)$的值主要取决于该边缘值，所以对边缘有强烈的响应。</p>
<p>以模板<img src="/2023/12/07/digitalImageProcessing-lab3/image.png" alt="Alt text">为例：<br>$g(x,y) &#x3D; 5 × f(x,y) - [f(\text{上})+f(\text{下})+f(\text{左})+f(\text{右})]$<br>化简后得<br>$g(x,y) &#x3D; f(x,y) + [4 × f(x,y)-[f(\text{上})+f(\text{下})+f(\text{左})+f(\text{右})]]$</p>
<p>如果该区域为平坦区域，则 $g(x,y)$ 结果为$f(x,y) + 0$，即对平坦区域实现0响应,该店像素值不变。</p>
<p>如果该区域为边缘，则在$[f(\text{上})、f(\text{下})、f(\text{左})、f(\text{右})]$中有一个与其它像素值不同，那么$g(x,y) &#x3D; f(x,y) + [f(x,y) - f(\text{边缘像素值差值})]$，所以对边缘有强烈的响应，并且锐化增强图像。</p>
<p>对于上述的<strong>基本</strong>拉普拉斯变换图像增强和拉普拉斯<strong>变体</strong>变换图像增强，其卷积核中间系数与其它系数相加不等于0是因为需要加上原图，而系数等于0则是该卷积核对边缘区域的响应非常剧烈而对平坦区域（即非边缘区域）响应为0。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">image,file_path</span>):</span><br><span class="line">    image.save(file_path)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">progress_img</span>(<span class="params">image,kernel</span>):</span><br><span class="line">    width,height = image.size</span><br><span class="line">    reslut_pixels = []</span><br><span class="line">    kernel_size = <span class="built_in">len</span>(kernel)</span><br><span class="line">    offset = kernel_size // <span class="number">2</span></span><br><span class="line">                        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            <span class="comment"># 计算卷积后的像素值</span></span><br><span class="line">            pixel_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(kernel)):</span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(kernel[<span class="number">0</span>])):</span><br><span class="line">                    <span class="keyword">if</span>(((x + n - <span class="number">1</span>)&gt;=width <span class="keyword">or</span> (x + n - <span class="number">1</span>)&lt;<span class="number">0</span>) <span class="keyword">or</span> ((y + m - <span class="number">1</span>)&gt;=height <span class="keyword">or</span> (y + m - <span class="number">1</span>)&lt;<span class="number">0</span> )):</span><br><span class="line">                        pixel_sum+=<span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pixel_sum += image.getpixel((x + n - <span class="number">1</span>, y + m - <span class="number">1</span>)) * kernel[m][n]</span><br><span class="line">                           </span><br><span class="line">            reslut_pixels.append(pixel_sum)  </span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 形成新图像</span></span><br><span class="line">    result_img = Image.new(<span class="string">&quot;L&quot;</span>,(width,height))</span><br><span class="line">    result_img.putdata(reslut_pixels)</span><br><span class="line">    <span class="keyword">return</span> result_img</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    input_filepath = <span class="string">&#x27;./img1/img1.tif&#x27;</span></span><br><span class="line">    output_fielpath = <span class="string">&#x27;./img1/bGaussian_lpls_17.bmp&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拉普拉斯变换卷积核</span></span><br><span class="line">    basic_lpls_kernel = [[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                         [-<span class="number">1</span>,<span class="number">4</span>,-<span class="number">1</span>],</span><br><span class="line">                         [<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">    </span><br><span class="line">    variant_lpls_kernel = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                           [<span class="number">1</span>,-<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">                           [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">    </span><br><span class="line">    Gaussian_lpls_kernel = [[<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                            [<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                            [-<span class="number">1</span>,-<span class="number">2</span>,<span class="number">17</span>,-<span class="number">2</span>,-<span class="number">1</span>],</span><br><span class="line">                            [<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                            [<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取图片</span></span><br><span class="line">    origin_img = read_image(input_filepath)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理并获得基本拉普拉斯变换图片</span></span><br><span class="line">    <span class="comment"># basic_lpls_img = progress_img(origin_img,basic_lpls_kernel)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># # 变体拉普拉斯变换图像</span></span><br><span class="line">    <span class="comment"># variant_lpls_img = progress_img(origin_img,variant_lpls_kernel)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 高斯拉普拉斯变换图像</span></span><br><span class="line">    Gaussian_lpls_img = progress_img(origin_img,Gaussian_lpls_kernel)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 展示图片</span></span><br><span class="line">    origin_img.show(title=<span class="string">&#x27;Origin image&#x27;</span>)</span><br><span class="line">    Gaussian_lpls_img.show(title=<span class="string">&#x27;variant_lpls5_image&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存图片</span></span><br><span class="line">    save_image(Gaussian_lpls_img,output_fielpath)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="图1"><a href="#图1" class="headerlink" title="图1"></a>图1</h3><div>
    </div><br><br><div style="display: flex; flex-wrap: wrap; justify-content: center;">
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img1/img1.bmp" alt="bright" style="zoom: 50%;">
    <p><em>Image 1: Original Image</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img1/basic_lpls5.bmp" alt="bright" style="zoom: 50%;">
    <p><em>Image 2: Basic Laplacian</em></p>
  </div><br><br>
<div style="display: flex; flex-wrap: wrap; justify-content: center;">
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img1/variant_lpls_9.bmp" alt="bright" style="zoom: 50%;">
    <p><em>Image 3: Variant Laplacian</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img1/bGaussian_lpls_17.bmp" alt="bright" style="zoom: 50%;">
    <p><em>Image 2: Gaussian Laplacian</em></p>
  </div>
    <br><br></div> </div>  



<h3 id="图2"><a href="#图2" class="headerlink" title="图2"></a>图2</h3><p><br><br><div style="display: flex; flex-wrap: wrap; justify-content: center;"><br>  <div style="margin: 10px; text-align: center;"><br>    <img src="/2023/12/07/digitalImageProcessing-lab3/img2/img2.bmp" alt="bright" style="zoom: 40%;"><br>    <p><em>Image 5: Original Image</em></p><br>  </div><br>  <div style="margin: 10px; text-align: center;"><br>    <img src="/2023/12/07/digitalImageProcessing-lab3/img2/basic_lpls_5.bmp" alt="bright" style="zoom: 40%;"><br>    <p><em>Image 6: Basic Laplacian</em></p><br>  </div></div></p>

<div style="display: flex; flex-wrap: wrap; justify-content: center;">  
<div style="margin: 10px; text-align: center;">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img2/variant_lpls_9.bmp" alt="bright" style="zoom: 40%;">
    <p><em>Image 7: Variant Laplacian</em></p>
  </div>
  <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img2/Gaussian_lpls_17.bmp" alt="bright" style="zoom: 40%;">
    <p><em>Image 8: Gaussian Laplacian</em></p>
  </div>
</div><br><br>





<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h5 id="对于图一："><a href="#对于图一：" class="headerlink" title="对于图一："></a>对于图一：</h5><p><strong>基本拉普拉斯变换</strong>,图像在原图的基础上，额外增加了如<em>Image 9</em>的细节,实现了边缘的锐化</p>
<p><br><div style="margin: 10px; text-align: center;"><br>    <img src="/2023/12/07/digitalImageProcessing-lab3/img1/basic_lpls4.bmp" alt="bright" style="zoom: 80%;"><br>    <p><em>Image 9: 基本拉普拉斯变换增强的细节</em></p><br>  </div><br></p>
<p><strong>变体拉普拉斯变换</strong>，与基本拉普拉斯变换相比，更加强调了中心像素值的贡献程度，从而使得图像在变换后更加突出。</p>
<div><br><br><div style="margin: 10px; text-align: center;">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img1/variant_lpls_-8.bmp" alt="bright" style="zoom: 80%;">
    <p><em>Image 10: 变体拉普拉斯变换增强的细节</em></p>
    </div><br><br></div>





<p>上述两种变换都是$3×3$的卷积核，对细节的增强较少</p>
<p><strong>高斯拉普拉斯变换</strong>与上述两种变换相比，采用了$5×5$的卷积核，对细节增强更多，从<em>Image 11</em>即可体现，且因为拉普拉斯变换对噪声非常敏感，采用高斯拉普拉斯变换后会先除去部分噪声，再增强细节，效果会好上很多。</p>
 <div><br><br> <div style="margin: 10px; text-align: center;">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img1/Gaussian_lpls16.bmp" alt="bright" style="zoom: 80%;">
    <p><em>Image 11: 高斯拉普拉斯变换增强的细节</em></p>
     </div><br><br></div>





<h5 id="对于图二："><a href="#对于图二：" class="headerlink" title="对于图二："></a>对于图二：</h5><p>基本拉普拉斯便函和变体拉普拉斯变换对图二的细节增强如图<em>Image 12</em> 和 <em>Image 13</em> 和 <em>Image 14</em></p>
<div style="margin: 10px; text-align: center; flex:0 0 30%">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img2/basic_lpls_4.bmp" alt="bright" style="zoom: 50%;">
    <p><em>Image 12: 基本拉普拉斯变换增强的细节</em></p>
  </div>


  <div style="margin: 10px; text-align: center; flex:0 0  30%">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img2/variant_lpls_-8.bmp" alt="bright" style="zoom: 50%;">
    <p><em>Image 13: 变体拉普拉斯变换增强的细节</em></p>
  </div>

<div style="margin: 10px; text-align: center; flex:0 0  30%">
    <img src="/2023/12/07/digitalImageProcessing-lab3/img2/Gaussian_lpls_16.bmp" alt="bright" style="zoom: 50%;">
    <p><em>Image 14: 高斯拉普拉斯变换增强的细节</em></p>
  </div>




<p>可以看出效果与图一基本一致</p>
<p><a href="https://pihaoxuan.github.io/2023/12/07/digitalImageProcessing-lab3/lab3.pdf">this is a preview</a></p>
<p><br><br><br></p>
<div class="pdfobject-container" data-target="https://pihaoxuan.github.io/2023/12/07/digitalImageProcessing-lab3/lab3.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数字图像处理实验三</tag>
      </tags>
  </entry>
  <entry>
    <title>digitalImageProcessing-lab2</title>
    <url>/2023/12/07/digitalImageProcessing-lab2/</url>
    <content><![CDATA[<p>实验二：算术均值滤波、几何均值滤波、逆谐波均值滤波、修正阿尔法均值滤波、中值滤波</p>
<span id="more"></span>

<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>掌握基本滤波算法的实现</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>①算术均值滤波<br>②几何均值滤波<br>③逆谐波均值滤波<br>④修正阿尔法均值滤波<br>⑤中值滤波</p>
<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h5 id="对于算术均值滤波，算法如下，其中m-x3D-n-x3D-3"><a href="#对于算术均值滤波，算法如下，其中m-x3D-n-x3D-3" class="headerlink" title="对于算术均值滤波，算法如下，其中m&#x3D;n&#x3D;3"></a>对于算术均值滤波，算法如下，其中m&#x3D;n&#x3D;3</h5><p><img src="/2023/12/07/digitalImageProcessing-lab2/image.png" alt="Alt text"></p>
<h5 id="对于几何均值滤波，算如下，其中m-x3D-n-x3D-3"><a href="#对于几何均值滤波，算如下，其中m-x3D-n-x3D-3" class="headerlink" title="对于几何均值滤波，算如下，其中m&#x3D;n&#x3D;3"></a>对于几何均值滤波，算如下，其中m&#x3D;n&#x3D;3</h5><p><img src="/2023/12/07/digitalImageProcessing-lab2/image-1.png" alt="Alt text"></p>
<h5 id="对于逆谐波均值滤波，算法如下，其中参数值在下面每张图上说明"><a href="#对于逆谐波均值滤波，算法如下，其中参数值在下面每张图上说明" class="headerlink" title="对于逆谐波均值滤波，算法如下，其中参数值在下面每张图上说明"></a>对于逆谐波均值滤波，算法如下，其中参数值在下面每张图上说明</h5><p><img src="/2023/12/07/digitalImageProcessing-lab2/image-2.png" alt="Alt text"></p>
<h5 id="对于修正阿尔法均值滤波，算法如下，其中参数值在下面每张图上说明"><a href="#对于修正阿尔法均值滤波，算法如下，其中参数值在下面每张图上说明" class="headerlink" title="对于修正阿尔法均值滤波，算法如下，其中参数值在下面每张图上说明"></a>对于修正阿尔法均值滤波，算法如下，其中参数值在下面每张图上说明</h5><p><img src="/2023/12/07/digitalImageProcessing-lab2/image-3.png" alt="Alt text"></p>
<h5 id="对于中值滤波，算法如下，其中模板大小为3×3"><a href="#对于中值滤波，算法如下，其中模板大小为3×3" class="headerlink" title="对于中值滤波，算法如下，其中模板大小为3×3"></a>对于中值滤波，算法如下，其中模板大小为3×3</h5><p>中值滤波根据给出的模板大小，讲模板内的像素值排序，以中间值为标准将模板内所有值改为中间值</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算数均值滤波</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">image,file_path</span>):</span><br><span class="line">    image.save(file_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_image</span>(<span class="params">image,kernel_size</span>):</span><br><span class="line">    width, height = image.size</span><br><span class="line">    filtered_pixels = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            <span class="comment"># 提取区域</span></span><br><span class="line">            region = []</span><br><span class="line">            <span class="comment"># 从kernel_size 的最左边到最右边，+1是控制边界能到最右边 因为range是左闭右开</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-kernel_size // <span class="number">2</span>, kernel_size // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-kernel_size // <span class="number">2</span>, kernel_size // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                    px, py = x + i, y + j</span><br><span class="line">                    <span class="comment"># 边界处理</span></span><br><span class="line">                    <span class="keyword">if</span>(px&gt;=width <span class="keyword">or</span> px&lt;<span class="number">0</span>):</span><br><span class="line">                        px=<span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span>(py&gt;=height <span class="keyword">or</span> py&lt;<span class="number">0</span>):</span><br><span class="line">                        py = <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 获取像素值</span></span><br><span class="line">                    region.append(image.getpixel((px, py)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算算数均值并更新像素值</span></span><br><span class="line">            mean_value = <span class="built_in">sum</span>(region) // <span class="built_in">len</span>(region)</span><br><span class="line">            filtered_pixels.append(mean_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建新图像</span></span><br><span class="line">    filtered_image = Image.new(<span class="string">&quot;L&quot;</span>, (width, height))</span><br><span class="line">    filtered_image.putdata(filtered_pixels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filtered_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">dir</span> = <span class="string">&quot;./img3/&quot;</span></span><br><span class="line">    image_name = <span class="string">&quot;img3.bmp&quot;</span></span><br><span class="line">    input_image_path = <span class="built_in">dir</span>+image_name</span><br><span class="line">    output_image_path = <span class="built_in">dir</span>+<span class="string">&quot;arithmetic.bmp&quot;</span></span><br><span class="line">    kernel_size = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    input_image = read_image(input_image_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 应用算数均值滤波器</span></span><br><span class="line">    filtered_image = process_image(input_image, kernel_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和滤波后的图像</span></span><br><span class="line">    input_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    filtered_image.show(title=<span class="string">&quot;Filtered Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存滤波后的图像</span></span><br><span class="line">    save_image(filtered_image, output_image_path)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 几何均值滤波</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">image,file_path</span>):</span><br><span class="line">    image.save(file_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_image</span>(<span class="params">image,kernel_size</span>):</span><br><span class="line">    width, height = image.size</span><br><span class="line">    filtered_pixels = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            <span class="comment"># 提取区域</span></span><br><span class="line">            region = []</span><br><span class="line">            <span class="comment"># 从kernel_size 的最左边到最右边，+1是控制边界能到最右边 因为range是左闭右开</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-kernel_size // <span class="number">2</span>, kernel_size // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-kernel_size // <span class="number">2</span>, kernel_size // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                    px, py = x + i, y + j</span><br><span class="line">                    <span class="comment"># 边界处理</span></span><br><span class="line">                    <span class="keyword">if</span>(px&gt;=width <span class="keyword">or</span> px&lt;<span class="number">0</span>):</span><br><span class="line">                        px=<span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span>(py&gt;=height <span class="keyword">or</span> py&lt;<span class="number">0</span>):</span><br><span class="line">                        py = <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 获取像素值</span></span><br><span class="line">                    region.append(image.getpixel((px, py)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算几何均值并更新像素值</span></span><br><span class="line">            geometric_mean_value = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> pixel_value <span class="keyword">in</span> region:</span><br><span class="line">                geometric_mean_value *= pixel_value</span><br><span class="line">            geometric_mean_value = <span class="built_in">int</span>(geometric_mean_value ** (<span class="number">1</span> / <span class="built_in">len</span>(region)))</span><br><span class="line">            filtered_pixels.append(geometric_mean_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建新图像</span></span><br><span class="line">    filtered_image = Image.new(<span class="string">&quot;L&quot;</span>, (width, height))</span><br><span class="line">    filtered_image.putdata(filtered_pixels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filtered_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">dir</span> = <span class="string">&quot;./img4/&quot;</span></span><br><span class="line">    image_name = <span class="string">&quot;img4.bmp&quot;</span></span><br><span class="line">    input_image_path = <span class="built_in">dir</span>+image_name</span><br><span class="line">    output_image_path = <span class="built_in">dir</span>+<span class="string">&quot;geometric.bmp&quot;</span></span><br><span class="line">    kernel_size = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    input_image = read_image(input_image_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 应用几何均值滤波器</span></span><br><span class="line">    filtered_image = process_image(input_image, kernel_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和滤波后的图像</span></span><br><span class="line">    input_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    filtered_image.show(title=<span class="string">&quot;Filtered Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存滤波后的图像</span></span><br><span class="line">    save_image(filtered_image, output_image_path)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 逆谐波均值滤波</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">image,file_path</span>):</span><br><span class="line">    image.save(file_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_image</span>(<span class="params">image,kernel_size,Q</span>):</span><br><span class="line">    width, height = image.size</span><br><span class="line">    filtered_pixels = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            <span class="comment"># 提取区域</span></span><br><span class="line">            region = []</span><br><span class="line">            <span class="comment"># 从kernel_size 的最左边到最右边，+1是控制边界能到最右边 因为range是左闭右开</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-kernel_size // <span class="number">2</span>, kernel_size // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-kernel_size // <span class="number">2</span>, kernel_size // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                    px, py = x + i, y + j</span><br><span class="line">                    <span class="comment"># 边界处理</span></span><br><span class="line">                    <span class="keyword">if</span>(px&gt;=width <span class="keyword">or</span> px&lt;<span class="number">0</span>):</span><br><span class="line">                        px=<span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span>(py&gt;=height <span class="keyword">or</span> py&lt;<span class="number">0</span>):</span><br><span class="line">                        py = <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 获取像素值</span></span><br><span class="line">                    region.append(image.getpixel((px, py)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算逆谐波均值并更新像素值</span></span><br><span class="line">            up = <span class="number">0</span></span><br><span class="line">            down = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> region:</span><br><span class="line">                <span class="keyword">if</span>(Q&lt;<span class="number">0</span>):</span><br><span class="line">                    up+=math.<span class="built_in">pow</span>(<span class="number">1</span>/item,<span class="built_in">abs</span>(Q+<span class="number">1</span>)) <span class="keyword">if</span> item !=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    down+=math.<span class="built_in">pow</span>(<span class="number">1</span>/item,<span class="built_in">abs</span>(Q)) <span class="keyword">if</span> item !=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    up+=math.<span class="built_in">pow</span>(item,(Q+<span class="number">1</span>)) </span><br><span class="line">                    down+=math.<span class="built_in">pow</span>(item,Q)</span><br><span class="line">            median_value = <span class="built_in">int</span>(up//down) <span class="keyword">if</span> down !=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            filtered_pixels.append(median_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建新图像</span></span><br><span class="line">    filtered_image = Image.new(<span class="string">&quot;L&quot;</span>, (width, height))</span><br><span class="line">    filtered_image.putdata(filtered_pixels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filtered_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    kernel_size = <span class="number">3</span></span><br><span class="line">    Q = <span class="number">2</span></span><br><span class="line">    <span class="built_in">dir</span> = <span class="string">&quot;./img4/&quot;</span></span><br><span class="line">    image_name = <span class="string">&quot;img4.bmp&quot;</span></span><br><span class="line">    input_image_path = <span class="built_in">dir</span>+image_name</span><br><span class="line">    output_image_path = <span class="built_in">dir</span>+<span class="string">&quot;contraharmonic_mean_Q=&quot;</span>+<span class="built_in">str</span>(Q)+<span class="string">&quot;_.bmp&quot;</span></span><br><span class="line"></span><br><span class="line">    input_image = read_image(input_image_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 应用逆谐波均值滤波器</span></span><br><span class="line">    filtered_image = process_image(input_image, kernel_size,Q)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和滤波后的图像</span></span><br><span class="line">    input_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    filtered_image.show(title=<span class="string">&quot;Filtered Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存滤波后的图像</span></span><br><span class="line">    save_image(filtered_image, output_image_path)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修正阿尔法均值滤波</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">image,file_path</span>):</span><br><span class="line">    image.save(file_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_image</span>(<span class="params">image,d,alpha</span>):</span><br><span class="line">    width, height = image.size</span><br><span class="line">    filtered_image = Image.new(<span class="string">&quot;L&quot;</span>,(width,height))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(d,width-d):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(d,height-d):</span><br><span class="line">            neighbors = []</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-d,d+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-d, d+<span class="number">1</span>):</span><br><span class="line">                    pixel_value = image.getpixel((x+i,y+i))</span><br><span class="line">                    neighbors.append(pixel_value)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 对neighbors内的元素排序</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(neighbors)):</span><br><span class="line">                key = neighbors[item]</span><br><span class="line">                j = item-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> key&lt;neighbors[j]:</span><br><span class="line">                    neighbors[j+<span class="number">1</span>] = neighbors[j]</span><br><span class="line">                    j-=<span class="number">1</span></span><br><span class="line">                neighbors[j+<span class="number">1</span>]=key</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 去除最大最小值</span></span><br><span class="line">            neighbors = neighbors[alpha:-alpha]</span><br><span class="line">            mean_value = <span class="built_in">sum</span>(neighbors)//<span class="built_in">len</span>(neighbors)</span><br><span class="line">            filtered_image.putpixel((x,y),mean_value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filtered_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    d = <span class="number">3</span></span><br><span class="line">    alpha = <span class="number">5</span></span><br><span class="line">    <span class="built_in">dir</span> = <span class="string">&quot;./img4/&quot;</span></span><br><span class="line">    image_name = <span class="string">&quot;img4.bmp&quot;</span></span><br><span class="line">    input_image_path = <span class="built_in">dir</span>+image_name</span><br><span class="line">    output_image_path = <span class="built_in">dir</span>+<span class="string">&quot;alpha_mean_alpha=&quot;</span>+<span class="built_in">str</span>(alpha)+<span class="string">&quot;_d=&quot;</span>+<span class="built_in">str</span>(d)+<span class="string">&quot;_.bmp&quot;</span></span><br><span class="line"></span><br><span class="line">    input_image = read_image(input_image_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 应用修正alpha均值滤波器</span></span><br><span class="line">    filtered_image = process_image(input_image, d,alpha)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和滤波后的图像</span></span><br><span class="line">    input_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    filtered_image.show(title=<span class="string">&quot;Filtered Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存滤波后的图像</span></span><br><span class="line">    save_image(filtered_image, output_image_path)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中值滤波</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">image, file_path</span>):</span><br><span class="line">    image.save(file_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_image</span>(<span class="params">image, kernel_size</span>):</span><br><span class="line">    width, height = image.size</span><br><span class="line">    filtered_pixels = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            <span class="comment"># 提取区域</span></span><br><span class="line">            region = []</span><br><span class="line">            <span class="comment"># 从kernel_size的最左边到最右边，+1是控制边界能到最右边，因为range是左闭右开</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-kernel_size // <span class="number">2</span>, kernel_size // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-kernel_size // <span class="number">2</span>, kernel_size // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                    px, py = x + i, y + j</span><br><span class="line">                    <span class="comment"># 边界处理</span></span><br><span class="line">                    <span class="keyword">if</span> px &gt;= width <span class="keyword">or</span> px &lt; <span class="number">0</span>:</span><br><span class="line">                        px = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span> py &gt;= height <span class="keyword">or</span> py &lt; <span class="number">0</span>:</span><br><span class="line">                        py = <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 获取像素值</span></span><br><span class="line">                    region.append(image.getpixel((px, py)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 手动实现排序</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(region)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(region) - i - <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> region[j] &gt; region[j + <span class="number">1</span>]:</span><br><span class="line">                        region[j], region[j + <span class="number">1</span>] = region[j + <span class="number">1</span>], region[j]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算中值并更新像素值</span></span><br><span class="line">            median_value = region[<span class="built_in">len</span>(region) // <span class="number">2</span>]</span><br><span class="line">            filtered_pixels.append(median_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建新图像</span></span><br><span class="line">    filtered_image = Image.new(<span class="string">&quot;L&quot;</span>, (width, height))</span><br><span class="line">    filtered_image.putdata(filtered_pixels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filtered_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">dir</span> = <span class="string">&quot;./img4/&quot;</span></span><br><span class="line">    image_name = <span class="string">&quot;img4.bmp&quot;</span></span><br><span class="line">    input_image_path = <span class="built_in">dir</span> + image_name</span><br><span class="line">    output_image_path = <span class="built_in">dir</span> + <span class="string">&quot;midvalue.bmp&quot;</span></span><br><span class="line">    kernel_size = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    input_image = read_image(input_image_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 应用中值滤波器</span></span><br><span class="line">    filtered_image = process_image(input_image, kernel_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和滤波后的图像</span></span><br><span class="line">    input_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    filtered_image.show(title=<span class="string">&quot;Filtered Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存滤波后的图像</span></span><br><span class="line">    save_image(filtered_image, output_image_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h4 id="图片顺序："><a href="#图片顺序：" class="headerlink" title="图片顺序："></a>图片顺序：</h4><h4 id="第一排依次是原图、算数"><a href="#第一排依次是原图、算数" class="headerlink" title="第一排依次是原图、算数"></a>第一排依次是原图、算数</h4><h4 id="第二排依次是几何、逆谐波"><a href="#第二排依次是几何、逆谐波" class="headerlink" title="第二排依次是几何、逆谐波"></a>第二排依次是几何、逆谐波</h4><h4 id="第三排依次是修正阿尔法、中值"><a href="#第三排依次是修正阿尔法、中值" class="headerlink" title="第三排依次是修正阿尔法、中值"></a>第三排依次是修正阿尔法、中值</h4><p>对于图片2-1来说，实验结果如下，其中逆谐波均值滤波Q&#x3D;-2，阿尔法修正中d＝3，α&#x3D;5</p>
<p><img src="/2023/12/07/digitalImageProcessing-lab2/img1/img1.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img1/arithmetic.bmp" alt="bright" style="zoom: 60%;"><br><img src="/2023/12/07/digitalImageProcessing-lab2/img1/geometric.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img1/contraharmonic_mean_Q=-2_.bmp" alt="bright" style="zoom: 60%;"><br><img src="/2023/12/07/digitalImageProcessing-lab2/img1/alpha_mean_alpha=5_d=3_.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img1/midvalue.bmp" alt="bright" style="zoom: 60%;"></p>
<p>对于图片2-2来说，实验结果如下，其中逆谐波均值滤波Q&#x3D;40，阿尔法修正中d&#x3D;3，α&#x3D;5</p>
<p><img src="/2023/12/07/digitalImageProcessing-lab2/img2/img2.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img2/arithmetic.bmp" alt="bright" style="zoom: 60%;"><br><img src="/2023/12/07/digitalImageProcessing-lab2/img2/geometric.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img2/contraharmonic_mean_Q=40_.bmp" alt="bright" style="zoom: 60%;"><br><img src="/2023/12/07/digitalImageProcessing-lab2/img2/alpha_mean_alpha=5_d=3_.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img2/midvalue.bmp" alt="bright" style="zoom: 60%;"></p>
<p>对于图片2-3来说实验结果如下，其中逆谐波均值滤波Q&#x3D;-2，阿尔法修正中d&#x3D;3，α&#x3D;3</p>
<p><img src="/2023/12/07/digitalImageProcessing-lab2/img3/img3.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img3/arithmetic.bmp" style="zoom:60%;"><br><img src="/2023/12/07/digitalImageProcessing-lab2/img3/geometric.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img3/contraharmonic_mean_Q=-2_.bmp" alt="bright" style="zoom: 60%;"><br><img src="/2023/12/07/digitalImageProcessing-lab2/img3/alpha_mean_alpha=3_d=3_.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img3/midvalue.bmp" alt="bright" style="zoom: 60%;"></p>
<p>对于图片2-4来说实验结果如下，其中逆谐波均值滤波Q&#x3D;-2，阿尔法修正中d&#x3D;3，α&#x3D;5</p>
<p><img src="/2023/12/07/digitalImageProcessing-lab2/img4/img4.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img4/arithmetic.bmp" alt="bright" style="zoom: 60%;"><br><img src="/2023/12/07/digitalImageProcessing-lab2/img4/geometric.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img4/contraharmonic_mean_Q=-2_.bmp" alt="bright" style="zoom: 60%;"><br><img src="/2023/12/07/digitalImageProcessing-lab2/img4/alpha_mean_alpha=5_d=3_.bmp" alt="bright" style="zoom: 60%;"><img src="/2023/12/07/digitalImageProcessing-lab2/img4/midvalue.bmp" alt="bright" style="zoom: 60%;"></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><p>在本次实验设计到的4个原图中，不论是从清晰度还是噪声去除上，所有图片都是中值滤波比其他所有不同的均值滤波效果要好。因为中值滤波选取一个模块内中间值作为该模块的标准值，而被噪声污染的像素值一般体现为很大或者很小的像素值，所以中值滤波能够完全规避很大或者很小的噪声的影响，而均值滤波虽然是在尽可能规避，但是因为其不抛弃噪声的像素，多少会受到影响。</p>
<h4 id="算数均值滤波"><a href="#算数均值滤波" class="headerlink" title="算数均值滤波"></a>算数均值滤波</h4><p>对于算数均值滤波来说，算数均值滤波是通过计算一个卷积核内的算术均值来去除噪声，虽然能够在一定程度上去除噪声的影响，但是这也会将细节信息在算数平均的过程中抹除，尤其是对于边缘信息来说，会使得边缘更加模糊。</p>
<h4 id="几何均值滤波"><a href="#几何均值滤波" class="headerlink" title="几何均值滤波"></a>几何均值滤波</h4><p>对于几何均值滤波，先幂次再开放的算法在对普通的卷积核内的像素的影响喝算术均值滤波的影响相差无几，但是对于边缘信息来说，因为边缘变化是一个陡峭的变化，一边非常小甚至接近于0，那么结果也是0，这样就会使得边缘信息得以保留。</p>
<h4 id="逆谐波均值滤波"><a href="#逆谐波均值滤波" class="headerlink" title="逆谐波均值滤波"></a>逆谐波均值滤波</h4><p>对于逆谐波均值滤波，有一个很重要的参数Q，当Q&#x3D;0时，等价于算数均值滤波，当Q&gt;0时，对椒噪声有较好的去除效果，所以对于图2-2，选择Q&#x3D;40的值来作为参数对图片降噪。<strong>当Q&#x3D;2时，确实得到了较好的结果，但是当Q&#x3D;4时，结果比Q&#x3D;2还要好，当我继续尝试增大Q值，比如Q&#x3D;40，发现效果并没有比Q&#x3D;4好很多，只是又亮了一些，所以并不值得</strong></p>
<p>而对于图2-3来说，当Q取负值的效果就比Q取正值的效果好很多，因为当Q取正值的时候对盐燥声的去除效果较好，同样<strong>当Q&#x3D;-2时，确实得到了较好的结果，但是当Q&#x3D;-4时，结果比Q&#x3D;2还要好，当我继续尝试增大Q值，比如Q&#x3D;-40，发现效果并没有比Q&#x3D;-4好很多，只是又暗了一些，清晰度并没有很大的变化，所以并不值得</strong></p>
<p>对于图2-4来说，并没有很明显的椒盐噪声，所以降噪的效果并不明显，只是Q&gt;0的时候图像更加亮，而Q&lt;0的时候图像更加暗</p>
<h4 id="修正阿尔法均值滤波"><a href="#修正阿尔法均值滤波" class="headerlink" title="修正阿尔法均值滤波"></a>修正阿尔法均值滤波</h4><p>对于所有的修正阿尔法均值滤波，算法中对卷积核内的像素值也做了“掐头去尾”的处理，但是还是对剩下的像素进行了平均求值，这也会将一些被污染程度轻的因素影响最终结果，而且与算数均值滤波一样，还会损失边缘信息，是图片变得模糊。<br>总的来说，阿尔法修正均值滤波使得图片更加模糊，但是边界比算数均值明显，而且图片像“打了马赛克”</p>
<p><a href="https://pihaoxuan.github.io/2023/12/07/digitalImageProcessing-lab2/lab2.pdf">this is a preview</a></p>
<div class="pdfobject-container" data-target="https://pihaoxuan.github.io/2023/12/07/digitalImageProcessing-lab2/lab2.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数字图像处理实验二</tag>
      </tags>
  </entry>
  <entry>
    <title>softwarerequest</title>
    <url>/2023/11/25/softwarerequest/</url>
    <content><![CDATA[<p>this page is some parts of software requests.</p>
<span id="more"></span>

<p>lab4:art:draw a diagram about login and staffs management.</p>
<p><a href="https://pihaoxuan.github.io/2023/11/25/softwarerequest/lab4.pdf">pdf file</a></p>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>软件需求分析实验</tag>
      </tags>
  </entry>
  <entry>
    <title>softwaretest</title>
    <url>/2023/11/22/softwaretest/</url>
    <content><![CDATA[<p>this page for software test experiments, taught by ZhangFY(dgut)</p>
<span id="more"></span>

<p>I will upload lab 1, lab 2, lab 3 later, but I did not sure when. </p>
<p>Following is lab 4. it about Base path testing,which means 基路径测试 in Chinese.</p>
<p><a href="https://pihaoxuan.github.io/2023/11/22/softwaretest/lab4.pdf">this is a preview</a></p>
<p>Following is lab5. it about data flow testing in a program, including judge Define-Use Path and Define-Clear Path.</p>
<p><a href="https://pihaoxuan.github.io/2023/11/22/softwaretest/lab5.pdf">this is a preview</a></p>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>软件测试实验</tag>
      </tags>
  </entry>
  <entry>
    <title>python_data_analysis</title>
    <url>/2023/11/21/python-data-analysis/</url>
    <content><![CDATA[<p>this blog is used to recode one of my course, named python data analysis. but I only upload some pdf-files about Experiments.</p>
<span id="more"></span>



<p>Lab 1 is about review of python language, so it is so simple to complete it.</p>
<p>Just a game, you can guess a number with your computer.</p>
<p><a href="https://pihaoxuan.github.io/2023/11/21/python-data-analysis/lab1.pdf">this is a link to preview pdf-file of lab 1</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">lower = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Please input a small number :&quot;</span>))</span><br><span class="line">hight = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Please input a bigger number :&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hight &lt; lower):</span><br><span class="line">        hight = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;bigger number can not smaller than small number ,please input bigger number again:&quot;</span>))</span><br><span class="line"></span><br><span class="line">answer = random.randint(lower,hight)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;you have 3 times to guess the number between the small number and the big number, and you can input -1 to exit this program.&quot;</span>)</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( count&lt;<span class="number">3</span> ):</span><br><span class="line">        guess = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;please input yor answer : &quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> (guess==answer):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;you are right, game over!&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">elif</span> (guess&lt;answer <span class="keyword">and</span> guess != -<span class="number">1</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Too small, please input angain: &quot;</span>)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(count ==<span class="number">3</span>):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;the answer is %d&quot;</span>,answer)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">elif</span> (guess &gt; answer <span class="keyword">and</span> guess != -<span class="number">1</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Too big, please input again:&quot;</span>)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(count==<span class="number">3</span>):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;the answer is&quot;</span>,answer)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">elif</span> (guess ==-<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;you kill the game, you are a bad man&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://pihaoxuan.github.io/2023/11/21/python-data-analysis/b.pdf">this is a link to preview pdf-file of lab 2</a></p>
<p>the profile of lab 2 I dont have time write it, but I will find some space time to write after these days.</p>
<p><a href="https://pihaoxuan.github.io/2023/11/21/python-data-analysis/c.pdf">this is a link to preview pdf-file of lab 3</a></p>
<p>the same as lab 2.</p>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>python数据分析实验</tag>
      </tags>
  </entry>
  <entry>
    <title>Mico_Lab_Meeting</title>
    <url>/2023/11/18/Mico-Lab-Meeting/</url>
    <content><![CDATA[<p>this page is recode for my PPTs while I discoursed in Mic_Lab_Metting </p>
<span id="more"></span>

<p>this PPT is used in 20230226 and it is my first discourse in this meeting, the following is my PPT, I wiil give you a preview and a link to read this PPT, perhaps you can download it when your browser support this action.</p>
<p>In my first discourse, I mainly talk about something what I have learned around that time. Just some principle of multiplication in a computer.</p>
<p><a href="https://pihaoxuan.github.io/2023/11/18/Mico-Lab-Meeting/Unsigned_Multiplication_and_Booth_Algorithm.pdf">Unsigned_Multiplication_and_Booth_Algorithm</a>(20230226)</p>
<p>the following PPT is my second discourse in this meeting that I mainly talk about some basic points and basic progresses in compliantion.</p>
<p><a href="https://pihaoxuan.github.io/2023/11/18/Mico-Lab-Meeting/Preliminary_Understanding_of_Compilation.pdf">Preliminary_Understanding_of_Compilation</a>(20230611)</p>
<p>The following PPT is my third discourse in this meeting, and it mainly talk about a lexical analysis in a compiler, including the process and how to read a string of input, how to identify a key word or a normal word and how to analysis the mean of this word, I interpret some method about it.</p>
<p><a href="https://pihaoxuan.github.io/2023/11/18/Mico-Lab-Meeting/Lexical_Analysis.pdf">Lexical_Analysis</a>(20231119)</p>
<p>The following PPT is my fourth discourse in this meeting, and it mainly talk about a paper named <a href="https://groups.csail.mit.edu/cag/slp/SLP-PLDI-2000.pdf">Exploiting Superword Level Parallelism with Multimedia Instruction Sets</a> ,which in Chinese means “SLP矢量化”.</p>
<p><a href="https://pihaoxuan.github.io/2023/11/18/Mico-Lab-Meeting/20240623%E7%BB%84%E4%BC%9A-SLP%E7%9F%A2%E9%87%8F%E5%8C%96.pdf">SLP矢量化</a>(20240623)</p>
]]></content>
      <categories>
        <category>Mico_Lab_Meeting_PPT</category>
      </categories>
      <tags>
        <tag>Mico_Lab_Meeting_PPT</tag>
      </tags>
  </entry>
  <entry>
    <title>digitalImageProcessing_lab1</title>
    <url>/2023/11/17/digitalImageProcessing-lab1/</url>
    <content><![CDATA[<p>实验一：直方图均衡化、对数变换、幂次变换</p>
<span id="more"></span>

<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>掌握基本图像增强算法的实现</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul>
<li>直方图均衡化图像增强</li>
<li>对数图像增强</li>
<li>幂次图像增强</li>
</ul>
<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h3 id="直方图均衡化图像增强"><a href="#直方图均衡化图像增强" class="headerlink" title="直方图均衡化图像增强"></a>直方图均衡化图像增强</h3><blockquote>
<p>①对图像遍历，统计出每个像素的出现次数（即频率），形成直方图</p>
<p>②对所有频率求和</p>
<p>③对直方图的每个频率除以所有频率的和，求出归一化到0-255的范围</p>
<p><img src="/2023/11/17/digitalImageProcessing-lab1/%E5%85%AC%E5%BC%8F1.jpg"></p>
</blockquote>
<h3 id="对数图像增强"><a href="#对数图像增强" class="headerlink" title="对数图像增强"></a>对数图像增强</h3><blockquote>
<p>s &#x3D; c * log(1+r)</p>
</blockquote>
<h3 id="幂次图像增强"><a href="#幂次图像增强" class="headerlink" title="幂次图像增强"></a>幂次图像增强</h3><blockquote>
<p>s &#x3D; c * pow(r,γ)</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直方图均衡化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="comment"># 使用PIL库读取图像</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转为灰度图像，L 代表灰度模式</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">histogram_equalization</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 获取图像的直方图</span></span><br><span class="line">    histogram = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">    width, height = image.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel_value = image.getpixel((x, y))</span><br><span class="line">            histogram[pixel_value] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算累积分布函数 列表</span></span><br><span class="line">    cumulative_distribution = [<span class="built_in">sum</span>(histogram[:i+<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 归一化到0-255的范围</span></span><br><span class="line">    normalized_cdf = [<span class="built_in">int</span>(cumulative_distribution[i]/cumulative_distribution[-<span class="number">1</span>] * <span class="number">255</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 应用均衡化</span></span><br><span class="line">    equalized_image = Image.new(<span class="string">&quot;L&quot;</span>, (width, height))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel_value = image.getpixel((x, y))</span><br><span class="line">            equalized_value = normalized_cdf[pixel_value]</span><br><span class="line">            equalized_image.putpixel((x, y), equalized_value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> equalized_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 读取图像</span></span><br><span class="line">    input_path = <span class="string">&quot;../clear.bmp&quot;</span></span><br><span class="line">    original_image = read_image(input_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行直方图均衡化</span></span><br><span class="line">    equalized_image = histogram_equalization(original_image)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和均衡化后的图像</span></span><br><span class="line">    original_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    equalized_image.show(title=<span class="string">&quot;Equalized Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存均衡化后的图像</span></span><br><span class="line">    output_path = <span class="string">&quot;../historgram_result/clear_my.bmp&quot;</span></span><br><span class="line">    equalized_image.save(output_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对数强化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="comment"># 使用PIL库读取图像</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转为灰度图像，L 代表灰度模式</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_transform</span>(<span class="params">image, c, base</span>):</span><br><span class="line">    width, height = image.size</span><br><span class="line"></span><br><span class="line">    equalized_image = Image.new(<span class="string">&quot;L&quot;</span>, (width, height))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel_value = image.getpixel((x, y))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对数变换t</span></span><br><span class="line">            log_transformed_value = c * math.log10(pixel_value + <span class="number">1</span>) / math.log10(base)</span><br><span class="line">            <span class="comment"># print(log_transformed_value)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将变换后的值限制在[0, 255]的范围内</span></span><br><span class="line">            log_transformed_value = (log_transformed_value/ math.log10(base))*<span class="number">255</span></span><br><span class="line"></span><br><span class="line">            equalized_image.putpixel((x, y), <span class="built_in">int</span>(log_transformed_value))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> equalized_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 读取图像</span></span><br><span class="line">    input_path = <span class="string">&quot;../lab1-7.tif&quot;</span></span><br><span class="line">    original_image = read_image(input_path)</span><br><span class="line"></span><br><span class="line">    base = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行直方图均衡化</span></span><br><span class="line">    equalized_image = log_transform(original_image,<span class="number">1</span>,base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和均衡化后的图像</span></span><br><span class="line">    original_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    equalized_image.show(title=<span class="string">&quot;Equalized Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存均衡化后的图像</span></span><br><span class="line">    output_path = <span class="string">&quot;../log_transform/lab1-7_my_&quot;</span>+<span class="built_in">str</span>(base)+<span class="string">&quot;_.tif&quot;</span></span><br><span class="line">    equalized_image.save(output_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 幂次强化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="comment"># 使用PIL库读取图像</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_path).convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转为灰度图像，L 代表灰度模式</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_transform</span>(<span class="params">image, c, base</span>):</span><br><span class="line">    width, height = image.size</span><br><span class="line"></span><br><span class="line">    equalized_image = Image.new(<span class="string">&quot;L&quot;</span>, (width, height))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel_value = image.getpixel((x, y))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 幂次变换</span></span><br><span class="line">            log_transformed_value = c * math.<span class="built_in">pow</span>(pixel_value,base)</span><br><span class="line">            <span class="comment"># print(log_transformed_value)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将变换后的值限制在[0, 255]的范围内</span></span><br><span class="line">            log_transformed_value = (log_transformed_value/ (math.<span class="built_in">pow</span>(<span class="number">255</span>,base)))*<span class="number">255</span></span><br><span class="line"></span><br><span class="line">            equalized_image.putpixel((x, y), <span class="built_in">int</span>(log_transformed_value))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> equalized_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 读取图像</span></span><br><span class="line">    input_path = <span class="string">&quot;../unclear.bmp&quot;</span></span><br><span class="line">    original_image = read_image(input_path)</span><br><span class="line"></span><br><span class="line">    base = <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行直方图均衡化</span></span><br><span class="line">    equalized_image = log_transform(original_image,<span class="number">1</span>,base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始图像和均衡化后的图像</span></span><br><span class="line">    original_image.show(title=<span class="string">&quot;Original Image&quot;</span>)</span><br><span class="line">    equalized_image.show(title=<span class="string">&quot;Equalized Image&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存均衡化后的图像</span></span><br><span class="line">    output_path = <span class="string">&quot;../power_transform/unclear_my_&quot;</span>+<span class="built_in">str</span>(base)+<span class="string">&quot;_.bmp&quot;</span></span><br><span class="line">    equalized_image.save(output_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>说明：第一行左边为原图，右边为直方图均衡化后的图；第二行左边为log变换后的图，右边为幂次变换后的图，参数会在对应位置说明</p>
<p>上传到网页，排版很可能出现问题，如果出问题，那么从上到下依次是 原图、直方图均衡化、log、幂次</p>
<p>下图log变换底数为300，幂次变换指数为5</p>
<p><img src="/2023/11/17/digitalImageProcessing-lab1/bright.bmp" alt="bright" style="zoom: 50%;"><img src="/2023/11/17/digitalImageProcessing-lab1/historgram_result/bright_my.bmp" alt="bright_my" style="zoom: 50%;"></p>
<p><img src="/2023/11/17/digitalImageProcessing-lab1/log_transform/bright_my_300_.bmp" alt="bright_my_30_" style="zoom:50%;"><img src="/2023/11/17/digitalImageProcessing-lab1/power_transform/bright_my_5_.bmp" alt="bright_my_5_" style="zoom:50%;"></p>
<p>下图log变换底数为100，幂次变换指数为2</p>
<p><img src="/2023/11/17/digitalImageProcessing-lab1/clear.bmp" alt="clear" style="zoom:50%;"><img src="/2023/11/17/digitalImageProcessing-lab1/historgram_result/clear_my.bmp" alt="clear_my" style="zoom:50%;"></p>
<p><img src="/2023/11/17/digitalImageProcessing-lab1/log_transform/clear_my_100_.bmp" alt="clear_my_100_" style="zoom:50%;"><img src="/2023/11/17/digitalImageProcessing-lab1/power_transform/clear_my_2_.bmp" alt="clear_my_2_" style="zoom:50%;"></p>
<p>下图log变换底数为50，幂次变换指数为0.5</p>
<p><img src="/2023/11/17/digitalImageProcessing-lab1/dark.bmp" alt="dark" style="zoom:50%;"><img src="/2023/11/17/digitalImageProcessing-lab1/historgram_result/dark_my.bmp" alt="dark_my" style="zoom:50%;"></p>
<p><img src="/2023/11/17/digitalImageProcessing-lab1/log_transform/dark_my_50_.bmp" alt="dark_my_50_" style="zoom:50%;"><img src="/2023/11/17/digitalImageProcessing-lab1/power_transform/dark_my_0.5_.bmp" alt="dark_my_0.5_" style="zoom:50%;"></p>
<p>下图log变换底数为100，幂次变换指数为2</p>
<p><img src="/2023/11/17/digitalImageProcessing-lab1/unclear.bmp" alt="unclear" style="zoom:50%;"><img src="/2023/11/17/digitalImageProcessing-lab1/historgram_result/unclear_my.bmp" alt="unclear_my" style="zoom:50%;"></p>
<p><img src="/2023/11/17/digitalImageProcessing-lab1/log_transform/unclear_my_100_.bmp" alt="unclear_my_100_" style="zoom:50%;"><img src="/2023/11/17/digitalImageProcessing-lab1/power_transform/unclear_my_2_.bmp" alt="unclear_my_2_" style="zoom:50%;"></p>
<p>下图log变换底数为100，幂次变换指数为2 （tif文件不能插入到markdown中，请看PDF文件）</p>
<p>PDF文件略有不同，影响不大<a href="https://pihaoxuan.github.io/2023/11/17/digitalImageProcessing-lab1/digitalImgPro_lab1.pdf">digitalImgPro_lab1.pdf </a></p>
<div class="pdfobject-container" data-target="https://pihaoxuan.github.io/2023/11/17/digitalImageProcessing-lab1/digitalImgPro_lab1.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数字图像处理实验1</tag>
      </tags>
  </entry>
  <entry>
    <title>clash_for_windows</title>
    <url>/2023/10/19/clash-for-windows/</url>
    <content><![CDATA[<p>clash for <strong>windows</strong> and clash for <strong>linux</strong> and clash for <strong>mac</strong></p>
<span id="more"></span>

<p>分享一款科学上网的软件：clash</p>
<p>有Windows版本的，也有Linux版本的，还有mac版本的。</p>
<p>以下就是下载链接了：</p>
<h3 id="下面三个都是Windows下的不同版本的clash"><a href="#下面三个都是Windows下的不同版本的clash" class="headerlink" title="下面三个都是Windows下的不同版本的clash"></a>下面三个都是Windows下的不同版本的clash</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/Clash.for.Windows-0.20.19-ia32-win.7z">Clash for <strong>Windows</strong> 0.20.19英文版本</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/Clash.for.Windows-0.20.21-win.7z">Clash for <strong>Windows</strong> 0.20.21英文版本</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/Clash.for.Windows.Setup.0.20.38.exe">Clash for <strong>Windows</strong> 0.20.38且汉化版本</a></p>
<p>我用的是<a href="https://github.com/pihaoxuan/pihaoxuan.github.io/releases/download/v1.0/Clash.Verge_2.0.0-rc.6_x64-setup.exe">clash verge</a></p>
<h3 id="在Linux系统上，又有两个不同的clash，一个是arm64架构下的Linux的clash，另一个是x64架构下的clash"><a href="#在Linux系统上，又有两个不同的clash，一个是arm64架构下的Linux的clash，另一个是x64架构下的clash" class="headerlink" title="在Linux系统上，又有两个不同的clash，一个是arm64架构下的Linux的clash，另一个是x64架构下的clash"></a>在Linux系统上，又有两个不同的clash，一个是arm64架构下的Linux的clash，另一个是x64架构下的clash</h3><h4 id="arm64架构"><a href="#arm64架构" class="headerlink" title="arm64架构"></a>arm64架构</h4><p><a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/download/0.20.38/Clash.for.Windows-0.20.38-arm64-linux.tar.gz">Clash.for.Linux-0.20.38-arm64</a></p>
<h4 id="x64架构"><a href="#x64架构" class="headerlink" title="x64架构"></a>x64架构</h4><p><a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/download/0.20.38/Clash.for.Windows-0.20.38-x64-linux.tar.gz">Clash.for.Linux-0.20.38-x64</a></p>
<h3 id="最后一个就是mac适用发clash了"><a href="#最后一个就是mac适用发clash了" class="headerlink" title="最后一个就是mac适用发clash了"></a>最后一个就是mac适用发clash了</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile2.0/Clash.for.Windows-0.20.38-arm64-mac.7z">Clash for mac 0.20.38版本</a></p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>关于git的一些使用心得</title>
    <url>/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>一些关于<strong>git</strong>使用的心得</p>
<span id="more"></span>

<p><strong>说明：本文使用Ubuntu20.04系统和gitee操作，理论上来说Windows系统和github的操作方法是一样的，只是有些路径不太一样。</strong></p>
<h3 id="预备条件"><a href="#预备条件" class="headerlink" title="预备条件"></a>预备条件</h3><p>首先需要有安装<code>git</code>（对于Windows平台来说，Linux应该是自带有git）</p>
<p>其次需要有gitee账号和一个新建的仓库</p>
<p>以上两项不会的自行查找资料，很简单的。(算了，我还是附上两（sì）个链接吧)</p>
<p><a href="https://blog.csdn.net/mukes/article/details/115693833?ops_request_misc=%7B%22request_id%22:%22169682895716800182799938%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169682895716800182799938&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115693833-null-null.142%5Ev95%5EchatgptT3_1&utm_term=git%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">Windows下的Git 详细安装教程——详细到你不想看</a></p>
<p><a href="https://blog.csdn.net/m0_70102063/article/details/132166986?ops_request_misc=&request_id=&biz_id=102&utm_term=Linux%E4%B8%8B%E7%9A%84git%E5%AE%89%E8%A3%85&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-132166986.142%5Ev95%5EchatgptT3_1&spm=1018.2226.3001.4187">Linux系统上安装Git详细步骤</a></p>
<p><strong>gitee账号创建：对不起太简单了，找不到教程</strong></p>
<p><a href="https://blog.csdn.net/qq_73805125/article/details/130659347?ops_request_misc=%7B%22request_id%22:%22169683556316800215058913%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=169683556316800215058913&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-130659347-null-null.142%5Ev95%5EchatgptT3_1&utm_term=gitee%E8%B4%A6%E5%8F%B7%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA&spm=1018.2226.3001.4187">怎么在Gitee中创建仓库</a></p>
<h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><p><strong>第一步</strong>：初始化git</p>
<p>在需要git管理的项目文件夹中执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/init.jpg" alt="init"></p>
<p>再执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">la</span><br></pre></td></tr></table></figure>

<p>就可以看见<code>.git</code>文件夹，证明初始化成功</p>
<p><img src="/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/la.jpg" alt="la"></p>
<p><strong>第二步</strong>：生成公钥以连接远程git仓库</p>
<p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的gitee账号的主邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>如果之前执行过，或者连过远程仓库，那么会报错说已经有了密钥</p>
<p><img src="/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/key_already_exists.jpg" alt="error"></p>
<p>如果没有过，那么<strong>注意</strong>：命令行会问你三个问题，别搭理他，直接回车让他尴尬就好了。之后会出现如图所示的奇怪图像</p>
<p><img src="/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/key_ok.jpg" alt="key_succeed"></p>
<p>然后去<code>/root/.ssh</code>下找到三个文件：<code>id_rsa</code>、<code>id_rsa.pub</code>和<code>known_hosts</code>。其中<code>id_rsa</code>是私钥，注意藏好，不要外泄；<code>id_rsa.pub</code>就是公钥，这个就有大用了。</p>
<p>点开<code>id_rsa.pub</code>文件，将里面的东西全都复制（<code>ctrl + a</code> 全选，然后复制），打开你的<code>gitee</code>网站，点击你自己的可可爱爱的头像，找到设置，点击设置</p>
<p><img src="/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/click_setting.jpg" alt="click_setting"></p>
<p>然后点击SSH公钥，输入标题，然后在公钥一栏种中粘贴刚刚复制的一堆东西</p>
<p><img src="/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/add_pub_key.jpg" alt="add_pub_key"></p>
<p>确定然后验证密码，就好了</p>
<p><strong>如果是之前有公钥的，可能会显示已经添加过，可以直接对仓库进行读写，可以直接忽略，问题不大</strong></p>
<p><strong>第三步</strong>：建立账号连接</p>
<p>直接在命令行输入以下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@git.oschina.net</span><br></pre></td></tr></table></figure>

<p>然后会显示啥呢？ 会和你问好，说你成功变成了作者balabala的，人还怪有礼貌的嘞！</p>
<p><img src="/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/successfully.jpg" alt="successfully"></p>
<p>至此，就可以连接上你的**<code>gitee</code>账号<strong>了，但是！！！！</strong>仅仅是连接到了你的gitee账号，而非仓库**，你还不能像高手一样<code>clone</code>、<code>push</code>和<code>pull</code>。</p>
<p><strong>第四步</strong>：连接仓库，芜湖！</p>
<p>打开网页，进入你开头新建的仓库看右边有个<code>克隆/下载</code>的明显的按钮，点击，选择<code>http</code>然后点击复制，这样就把这个仓库的网址复制下来了（其实点击SSH也行）</p>
<p>然后在切回命令行那边（<strong>注意，我们一直是在你需要用<code>git</code>管理的文件路径下操作的</strong>）输入以下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin 你刚刚复制的url地址</span><br></pre></td></tr></table></figure>

<p>然后检查一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p><img src="/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/git_remote_-v.jpg" alt="git_remote_-v"></p>
<p>出现这个就是成功了！</p>
<blockquote>
<p>解释一下，其中origin不是一个指令参数，是一个别名，就是在之后的push和pull中，你的origin就代表着你的仓库的地址，也可以设计别的名字，比如小猫，小狗，大逼兜等等，当然最好是英文。</p>
</blockquote>
<p><strong>第五步</strong>：愉快地上传代码</p>
<p>终于来到了经典的<code>push</code>三连了！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status //查看当前所做更改</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>第一条：将需要push的代码加载到工作区（本地）<code>.</code>的意思是本级目录下所有文件，也可以换成文件名或者路径</p>
<p>第二条：提交，但也是提交到本地，<code>message</code> 是你提交时候的备注，可以简要说明你做了啥，中英文都可以</p>
<p>第三条：将本地的东西全都<code>push</code>到远程仓库去，就是<code>gitee</code>上你创建的仓库。</p>
<blockquote>
<p>如果出现报错说你仓库有东西，两种解决方法</p>
<p><img src="/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/push_error.jpg"></p>
<p>①先将仓库里的东西clone下来，修改后成你想要的之后再push上去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone origin</span><br></pre></td></tr></table></figure>

<p>②如果仓库的东西不要，直接在<code>gitee</code>网站上清空仓库（<strong>慎重</strong>）然后再<code>push</code>上去</p>
</blockquote>
<p><img src="/2023/10/09/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/push_succeed.jpg"></p>
<p>出现上图就是成功了。</p>
<p>再去<code>gitee</code>上看，代码也成功push上去了！</p>
<h3 id="圆满！！"><a href="#圆满！！" class="headerlink" title="圆满！！"></a>圆满！！</h3><p>PS:第一次push的时候会让你登录<code>gitee</code>，需要输入用户名和密码；用户名就是<code>gitee</code>的用户名,密码就是<code>gitee</code>账户的密码</p>
<p>如果之后每次提交都需要重复上述操作，挺烦的，那么就可以打开你项目文件夹的<code>.git/config</code>文件，<code>.get</code>就是开头说的那个文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin]</span><br><span class="line">url = https://gitee啥啥啥的</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"></span><br><span class="line">[remote &quot;origin]</span><br><span class="line">url = https://用户名:密码@gitee啥啥啥的</span><br></pre></td></tr></table></figure>

<p><strong>注意：以上所有符号用英文！</strong></p>
<p>END</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>OCR</title>
    <url>/2023/09/17/OCR/</url>
    <content><![CDATA[<p>初探OCR图片文字识别技术</p>
<span id="more"></span>

<p>图片文字识别 是 从一幅图片中通过一些算法，将图片中的文字识别提取出来。</p>
<p>通常图片中文字的检测分为比较简单的场景和比较复杂的场景</p>
<p><img src="/2023/09/17/OCR/%E7%AE%80%E5%8D%95%E5%9C%BA%E6%99%AF%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB.jpg" alt="简单场景文字识别"></p>
<p>简单场景文字识别</p>
<p><img src="/2023/09/17/OCR/%E5%A4%8D%E6%9D%82%E5%9C%BA%E6%99%AF%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB.jpg" alt="复杂背景文字识别"></p>
<p>复杂场景文字识别</p>
<p>对于简单场景文字识别，可以使用比较简单的两种方法：<strong>形态学操作法</strong> 和 <strong>MSER+NMS</strong>。</p>
<p>对于复杂场景的文字识别，则有<strong>CTPN</strong>、<strong>Seglink</strong> 和 <strong>EAST</strong> 三种主流方法。</p>
<h3 id="形态学操作法"><a href="#形态学操作法" class="headerlink" title="形态学操作法"></a>形态学操作法</h3><p>①先将图片灰度化，及转换为灰度图</p>
<p>②将图片降噪后进行二值化</p>
<p><img src="/2023/09/17/OCR/%E4%BA%8C%E5%80%BC%E5%8C%96%E5%90%8E.jpg"></p>
<p>③通过膨胀，腐蚀等方法突出文本框范围</p>
<p><img src="/2023/09/17/OCR/%E8%86%A8%E8%83%80%E5%90%8E.jpg" alt="膨胀后的图片"></p>
<p>④进行可信度分析，即判断哪些范围是不属于文本的</p>
<p>⑤得到文本范围的坐标</p>
<p><img src="/2023/09/17/OCR/%E5%9D%90%E6%A0%87.jpg"></p>
<h3 id="MSER-NMS"><a href="#MSER-NMS" class="headerlink" title="MSER+NMS"></a>MSER+NMS</h3>]]></content>
      <categories>
        <category>OCR</category>
      </categories>
      <tags>
        <tag>OCR</tag>
      </tags>
  </entry>
  <entry>
    <title>Class about Java and Qt</title>
    <url>/2023/07/21/Class%20about%20Java%20and%20Qt/</url>
    <content><![CDATA[<p>This is a passage of something about Qt coding</p>
<span id="more"></span>

<h3 id="基于c-的Qt"><a href="#基于c-的Qt" class="headerlink" title="基于c++的Qt"></a>基于<code>c++</code>的<code>Qt</code></h3><p>在<code>Qt creator</code>中做<code>Qt</code>开发是基于<code>C++</code>的<code>Qt</code>开发，也即一种面向对象的<code>Qt</code>开发。</p>
<p>我是只学过<code>Java</code>，没学过<code>C++</code>的，于是与<code>Java</code>语言类比，发现了诸多类似与一些不同。</p>
<h3 id="关于Qt中的类"><a href="#关于Qt中的类" class="headerlink" title="关于Qt中的类"></a>关于<code>Qt</code>中的类</h3><p>在<code>Java</code>中，一个类可以拆解成（我所认为的）这么几部分：类名，成员变量和成员函数。</p>
<p>类名自然不用多说，切在类名后还可以实现继承和接口相关一些功能；成员变量和成员函数一起被一对<code>&#123;&#125;</code>包裹在类中。一般是先声明成员变量，再根据它们设计函数。</p>
<p>而在Qt中，需要在头文件中定义成员变量和声明成员函数，同时定义它们的作用范围，如下代码所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mainWidget.h 文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mybutton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PADDING 2</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123; UP=<span class="number">0</span>, DOWN=<span class="number">1</span>, LEFT, RIGHT, LEFTTOP, LEFTBOTTOM, RIGHTBOTTOM, RIGHTTOP, NONE &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">Widget</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mainWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mainWidget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">mainWidget</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">region</span><span class="params">(<span class="type">const</span> QPoint &amp;currentGlobalPoint)</span></span>;  <span class="comment">//鼠标的位置,改变光标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    QPoint m_movePoint;  <span class="comment">//鼠标的位置</span></span><br><span class="line">    <span class="type">bool</span> isLeftPressDown;  <span class="comment">// 判断左键是否按下</span></span><br><span class="line">    Direction dir;        <span class="comment">// 窗口大小改变时，记录改变方向</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//鼠标按下移动及释放事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWIDGET_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而成员函数的实现则在对应的<code>.cpp</code>文件中实现。</p>
<p>刚开始学<code>Qt</code>的时候，看到教程在不停的换文件编辑，觉得非常乱，了解这一点之后可以很清楚的知道什么内容要到什么文件中去编辑。</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>class17</title>
    <url>/2023/06/19/class17/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0115c9a67823bdc3a3c5ff45510d6d46602fee6cefd4037c6eef1fbd35a7fca6">042a9b5b09e3698fdc064d0eabb03174421f884bf588e71315cd298b985cd9173f4e934906bdaa7a37e615a388973f81a65febd43c8e2b1075b84d58a9fcaa35080ad74f9808918d743a042cc0d1477700c90b65a037a03ee1f40b294484b3809f9dc3c31633a52a9eb95aba3f14a0f61027e390a66ebb25bf3ad78a633f2b1f3c693e8e8f37ffad2da496ebc8bdaeb158c8d6443dd159a256b1ec8e6803df085f2fb6ea2cff2a797b167b5a8cffac7a2f5c7a7ac19699819ad7f9d78f50981deab71506bcf7eacd139bdbcfcef5a94b10212ba553237ed5083f47cc4591a502cc2f84e874986596deb492383fc10e5ba02494d9f3a2c469afdd1c28df344f7415bd84d3f0171a3995bc435d1fbcf1b8fe6e434fd96d9484794888505fce47472b518d90e585a392eb20cf5d873ea45ba4938ae4d6b513e91992df1b730117b5e634f1a240dcb01fd97d190ce5c03aef84764c24ad5d5de9cef4a32a83d224962a135d49b4d4ca03a490c0770a11f4e8814617fee958444322480570369da08483330af10d82d6e69bf02252a355452c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>高三17班</category>
      </categories>
      <tags>
        <tag>高三17班</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机指令解释</title>
    <url>/2023/06/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>简易编译器中的虚拟机指令解释</p>
<span id="more"></span>

<h3 id="代码前定义"><a href="#代码前定义" class="headerlink" title="代码前定义"></a>代码前定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *src, *old_src;</span><br><span class="line"><span class="type">int</span> *bp, *sp, *pc; </span><br><span class="line"><span class="type">int</span> ax = <span class="number">0</span>; </span><br></pre></td></tr></table></figure>



<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> //枚举</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LEA,IMM,JMP,CALL,JZ,JNZ,ENT,ADJ,LEV,LI,LC,SI,SC,PUSH,OR,XOR,AND,EQ,NE,LT,GT,LE,GE,SHL,SHR,ADD,SUB,MUL,DIV,MOD,OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IMM"><a href="#IMM" class="headerlink" title="IMM"></a>IMM</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == IMM)</span><br><span class="line">&#123;</span><br><span class="line">	ax = *pc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IMM</code>指令用于将一个<code>数</code>存放在寄存器<code>ax</code>中。</p>
<p>其中<code>数</code>不一定是1，2，3，4等，可以是其它不同含义的数字，比如十六进制的<code>0xE4BDA0</code>在<code>utf-8</code>中表示中文字符<code>你</code>，也可以当作一个数存进寄存器<code>ax</code>中。</p>
<p><code>pc</code>指向的是下一个指令的地址，地址本质上也是一个数，即可以存储到寄存器<code>ax</code>中。</p>
<h3 id="LC"><a href="#LC" class="headerlink" title="LC"></a>LC</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LC)</span><br><span class="line">&#123;</span><br><span class="line">	ax = *(<span class="type">char</span> *)ax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LC</code>指令用于将对应地址中的字符载入<code>ax</code>中。</p>
<p>执行指令前，<code>ax</code>中存放的是地址，一如IMM指令中所述，将该地址存放在<code>ax</code>中。现将<code>ax</code>中的地址强转为 <code>char *</code> （因为<code>ax</code>是<code>int</code>型） ，强转为<code>char * </code>只是告诉编译器，我下一次要取<code>ax</code>地址中对应的内容时，按照<code>char</code>的解析规则去解析，即随即而来的解引用操作，将<code>ax</code>中的地址值指向的内容，按照<code>char</code>的规则解析后，将其的编码（若是字母，则应该是ASCII码，如果是其它的字符，则是按照编码规则来存储的一些十六进制的码）存入<code>ax</code>中。</p>
<h3 id="LI"><a href="#LI" class="headerlink" title="LI"></a>LI</h3><p><code>LI</code>指令用于将对应地址中的整数载入<code>ax</code>中，和<code>LC</code>类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LI)</span><br><span class="line">&#123;</span><br><span class="line">    ax = *(<span class="type">int</span> *)ax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SC"><a href="#SC" class="headerlink" title="SC"></a>SC</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SC)</span><br><span class="line">&#123;</span><br><span class="line">	ax = *(<span class="type">char</span> *)*sp++ = ax;<span class="comment">//sp++是压栈？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SC</code>指令用于将<code>ax</code>中的数据作为字符存放，且存放在栈顶。</p>
<p>首先POP一下，即<code>sp++</code>，然后将<code>ax</code>存放在<code>sp</code>指向的内存中。完成之后，将该地址强转为 <code>char *</code>类型，之后再按照<code>char</code>的规则取该地址中的内容，然后存入<code>ax</code>中。</p>
<p>简而言之，先将<code>ax</code>中的数存入<code>sp</code>栈顶中，然后将它转换成<code>char</code>类型，再更新<code>ax</code>中的值。</p>
<p>其实可以写成这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == SC)</span><br><span class="line">&#123;</span><br><span class="line">    *sp++ = ax;</span><br><span class="line">    ax = *(<span class="type">char</span> *)*sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SI"><a href="#SI" class="headerlink" title="SI"></a>SI</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SI)</span><br><span class="line">&#123;</span><br><span class="line">	*(<span class="type">int</span> *)*sp++ = ax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>SC</code>类似，但是 是将<code>ax</code>中的数据以整数的形式重新存入<code>ax</code>中</p>
<h3 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH"></a>PUSH</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == PUSH)</span><br><span class="line">&#123;</span><br><span class="line">	*--sp = ax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PUSH</code>即为压栈，先开辟空间，即sp向下走一位，然后将<code>ax</code>的值写进去</p>
<h3 id="JMP"><a href="#JMP" class="headerlink" title="JMP"></a>JMP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == JMP)</span><br><span class="line">&#123;</span><br><span class="line">	pc = (<span class="type">int</span> *)*pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JMP</code>的作用是跳转，即将<code>pc</code>指向的地址中的值改为下一块语句的地址。</p>
<blockquote>
<p><strong>注意</strong></p>
<p><code>JMP</code>是跳转到下一块，因为这是跳转，而不是按照顺序继续执行，中间必然是跳跃的一些代码的</p>
<p>若需要按顺序执行下一条语句，直接<code>pc++</code>就可以事项，在<code>JZ</code>和<code>JNZ</code>指令中有体现</p>
</blockquote>
<p><code>pc</code>中存放的是<strong>下一条指令的地址的地址</strong>，该操作是将下一条指令的地址直接赋给<code>pc</code>并以<code>int</code>规则解析该地址（因为<code>pc</code>本来就是<code>int *</code>类型）</p>
<h3 id="JZ"><a href="#JZ" class="headerlink" title="JZ"></a>JZ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == JZ)</span><br><span class="line">&#123;</span><br><span class="line">	pc = ax ? pc + <span class="number">1</span> : (<span class="type">int</span> *)*pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JZ</code>：jump if ax is zero</p>
<p>即当<code>ax</code>为0时，使用<code>JZ</code>跳转到<code>(int *)*pc</code></p>
<h3 id="JNZ"><a href="#JNZ" class="headerlink" title="JNZ"></a>JNZ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == JNZ)</span><br><span class="line">&#123;</span><br><span class="line">	pc = ax ? (<span class="type">int</span> *)*pc : pc + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JNZ</code>：jump if ax is not zero</p>
<p>即当<code>ax</code>不为0时，使用<code>JNZ</code>跳转到<code>(int *)*pc</code></p>
<h3 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == CALL)</span><br><span class="line">&#123;</span><br><span class="line">	sp--;</span><br><span class="line">	*sp = (<span class="type">int</span>)(pc + <span class="number">1</span>);</span><br><span class="line">	pc = (<span class="type">int</span> *)*pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CALL</code>用于调用子函数。</p>
<p>先将栈开辟一块空间，然后将顺序的下一句存进栈顶，然后实现一次<code>JMP</code>，跳转到子函数的地址。</p>
<blockquote>
<p>将顺序的下一句存入栈中，是因为等子函数执行完了之后，需要回过头来继续执行main函数</p>
</blockquote>
<h3 id="ENT"><a href="#ENT" class="headerlink" title="ENT"></a>ENT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == ENT)</span><br><span class="line">&#123;</span><br><span class="line">	*--sp = (<span class="type">int</span>)bp;</span><br><span class="line">	bp = sp;</span><br><span class="line">	sp = sp - *pc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ENT</code>用于保存当前栈指针，然后分配一定空间给子函数运行</p>
<p>先调用基址指针<code>bp</code>来帮忙代替一下<code>sp</code>的工作：总是指向栈顶。在这之前需要在栈中保存基址指针指向的地址，即先分配空间保存<code>bp</code>的指向内容，然后将<code>sp</code>的值赋给<code>bp</code>，然后<code>sp</code>划分<code>*pc++</code>个空间给子函数运行。</p>
<blockquote>
<p><code>pc++</code>是<code>CALL</code>之后<code>pc</code>的顺序的下一个指令地址，里面存储了该函数需要多少空间才能保证顺利运行，所以编译器可以直接按照这个数字给子函数开辟内存</p>
</blockquote>
<h3 id="ADJ"><a href="#ADJ" class="headerlink" title="ADJ"></a>ADJ</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == ADJ)</span><br><span class="line">&#123;</span><br><span class="line">	sp = sp + *pc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ADJ</code>函数用于回收给子函数分配的空间。</p>
<h3 id="LEV"><a href="#LEV" class="headerlink" title="LEV"></a>LEV</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LEV)</span><br><span class="line">&#123;</span><br><span class="line">	sp = bp;</span><br><span class="line">	bp = (<span class="type">int</span> *)*sp++;</span><br><span class="line">	pc = (<span class="type">int</span> *)*sp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LEV</code>用于恢复没调用函数时的main函数的现场。</p>
<p>在<code>CALL</code>指令中，将顺序执行的下一条语句地址暂存，在<code>ENT</code>指令中，将基址指针<code>bp</code>的指向地址暂存，然后<code>bp</code>代替<code>sp</code>先指一会儿栈顶。</p>
<p>所以先将栈顶指针还给<code>sp</code>，然后带<code>bp</code>去找它之前指向的地址，然后把存该地址的空间消灭，接着就带<code>pc</code>去找顺序下一条语句的地址（因为中间插入的函数已经解决了），然后再将该空间消灭。</p>
<blockquote>
<p>先带<code>bp</code>，再带<code>pc</code>顺序不可乱，因为栈就是后进先出！！</p>
</blockquote>
<h3 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LEA)</span><br><span class="line">&#123;</span><br><span class="line">	ax = (<span class="type">int</span>)(bp + *pc++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LEA</code>指令用于取函数参数。</p>
<p><code>CALL</code>指令执行后，跳转至子函数执行，此时需要取子函数的参数。子函数的参数位置由基址指针<code>bp</code>和偏移量<code>*pc</code>决定，取完之后，将其存放到寄存器<code>ax</code>中</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>①在<code>JZ</code>和<code>JNZ</code>中，已经确定了两种情况下的<code>ax</code>为什么还需要用三目操作符来判断<code>ax</code>的值并给出相应的操作，且不管<code>ax</code>是否为0，结果都是一样的，即进行一次<code>JMP</code></p>
<p>②在<code>ENT</code>和<code>ADJ</code>中都涉及到了<code>*pc++</code>这个数值，但是在<code>ENT</code>分配的时候就已经调用了<code>*pc++</code>，理论上<code>pc</code>已经不再指向该函数需要的运行空间了，为什么在<code>ADJ</code>中还可以继续用<code>*pc++</code>来回收空间，此时的<code>pc</code>不应该指向其他值吗？</p>
]]></content>
      <categories>
        <category>编译</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2023/06/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>操作系统</p>
<span id="more"></span>



<h3 id="关于操作系统课程教材《Linux编程》中代码不能正常编译问题解释："><a href="#关于操作系统课程教材《Linux编程》中代码不能正常编译问题解释：" class="headerlink" title="关于操作系统课程教材《Linux编程》中代码不能正常编译问题解释："></a>关于操作系统课程教材《Linux编程》中代码不能正常编译问题解释：</h3><p>书中大部分代码使用头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrapper.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>在文件<code>wrapper.h</code>中，作者引用了大量的其他头文件，以及其他函数和作者对此书适应的定义，若没有该文件，此书中的很多代码编译运行的体验感不好。因此这里给出<code>wrapper.h</code>文件内容，及其使用方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* $begin wrapper.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __WRAPPER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WRAPPER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Default file permissions are DEF_MODE &amp; ~DEF_UMASK */</span></span><br><span class="line"><span class="comment">/* $begin createmasks */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_MODE   S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_UMASK  S_IWGRP|S_IWOTH</span></span><br><span class="line"><span class="comment">/* $end createmasks */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Simplifies calls to bind(), connect(), and accept() */</span></span><br><span class="line"><span class="comment">/* $begin sockaddrdef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br><span class="line"><span class="comment">/* $end sockaddrdef */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Persistent state for the robust I/O (Rio) package */</span></span><br><span class="line"><span class="comment">/* $begin rio_t */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIO_BUFSIZE 8192</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;                <span class="comment">/* descriptor for this internal buf */</span></span><br><span class="line">    <span class="type">int</span> rio_cnt;               <span class="comment">/* unread bytes in internal buf */</span></span><br><span class="line">    <span class="type">char</span> *rio_bufptr;          <span class="comment">/* next unread byte in internal buf */</span></span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE]; <span class="comment">/* internal buffer */</span></span><br><span class="line">&#125; <span class="type">rio_t</span>;</span><br><span class="line"><span class="comment">/* $end rio_t */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  semaphore buffer structure */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">               <span class="type">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">               <span class="type">unsigned</span> <span class="type">short</span>  *<span class="built_in">array</span>;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">/* Buffer for IPC_INFO</span></span><br><span class="line"><span class="comment">                                           (Linux-specific) */</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* External variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> h_errno;    <span class="comment">/* defined by BIND for DNS errors */</span> </span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ; <span class="comment">/* defined by libc */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc constants */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MAXLINE	 8192  <span class="comment">/* max text line length */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBUF   8192  <span class="comment">/* max I/O buffer size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTENQ  1024  <span class="comment">/* second argument to listen() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Our own error-handling functions */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ux_error</span><span class="params">(<span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">posix_error</span><span class="params">(<span class="type">int</span> code, <span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dns_error</span><span class="params">(<span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span> *msg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process control wrappers */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *iptr, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Getpgrp</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Signal wrappers */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">handler_t</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unix I/O wrappers */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">//#define Open(pathname, flags) Open(pathname, flags, 0666)</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">Lseek</span><span class="params">(<span class="type">int</span> fildes, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Select</span><span class="params">(<span class="type">int</span>  n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, </span></span><br><span class="line"><span class="params">	   <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Dup2</span><span class="params">(<span class="type">int</span> fd1, <span class="type">int</span> fd2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory mapping wrappers */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Standard I/O wrappers */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line">FILE *<span class="title function_">Fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">Fgets</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">int</span> n, FILE *stream)</span>;</span><br><span class="line">FILE *<span class="title function_">Fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">Fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Dynamic storage allocation wrappers */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">Realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">Calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sockets interface wrappers */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Setsockopt</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">int</span> optlen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *my_addr, <span class="type">int</span> addrlen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">int</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DNS wrappers */</span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">Gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">Gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *addr, <span class="type">int</span> len, <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pthreads thread control wrappers */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tidp, <span class="type">pthread_attr_t</span> *attrp, </span></span><br><span class="line"><span class="params">		    <span class="type">void</span> * (*routine)(<span class="type">void</span> *), <span class="type">void</span> *argp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">Pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_function)())</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* POSIX semaphore wrappers */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rio (Robust I/O) package */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>; </span><br><span class="line"><span class="type">ssize_t</span>	<span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span>	<span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrappers for Rio package */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>; </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Client/server helper functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_client_sock</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">int</span> portno)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open_listen_sock</span><span class="params">(<span class="type">int</span> portno)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrappers for client/server helper functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Open_client_sock</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">int</span> port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Open_listen_sock</span><span class="params">(<span class="type">int</span> port)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrappers for System V IPC functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Msgrcv</span><span class="params">(<span class="type">int</span> maqid, <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">Shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, <span class="keyword">union</span> semun arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sem, <span class="type">int</span> sops)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __WRAPPER_H__ */</span></span></span><br><span class="line"><span class="comment">/* $end wrapper.h */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大家可以直接在文件夹中创建文件<code>wrapper.h</code>,然后编译。</p>
<p>如果此方法发不行，那么，按照下面方法来：</p>
<p>①下载附件：<a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/wrapper.zip">wrapper.h解决办法</a></p>
<p>②将附件中的除使用说明文件以外的四个文件复制，放入和需要该头文件的代码同一文件夹内。</p>
<p>③按照使用说明文件中的说明操作：</p>
<p>​	先执行下列命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rm libwrapper.a</span><br><span class="line">gcc  -c    wrapper.c  ptwrapper.c</span><br><span class="line">ar  rc  libwrapper.a  wrapper.o  ptwrapper.o</span><br></pre></td></tr></table></figure>

<p>​	都正常执行后，既可以编译需要编译的文件，编译文件时使用如下命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc yourfile.c -o yourfilename -L. -lwrapper</span><br></pre></td></tr></table></figure>

<p>​	既可以成功编译，生成二进制文件</p>
<h3 id="下面是实验时间！"><a href="#下面是实验时间！" class="headerlink" title="下面是实验时间！"></a>下面是实验时间！</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%88%E6%97%A0%E9%80%89%E5%81%9A%EF%BC%89.tar">lab4:进程间通信(无选做)</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/pihaoxuan_2021428010127_05.tar.zip">lab5:网络通信源代码</a></p>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2023/05/30/Vue/</url>
    <content><![CDATA[<p>Vue前端开发</p>
<span id="more"></span>

<h3 id="实验三：投票系统的实现"><a href="#实验三：投票系统的实现" class="headerlink" title="实验三：投票系统的实现"></a>实验三：投票系统的实现</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/Vue-lab3-vote-system.zip">实验三：投票系统的实现（npm组件工程项目）<strong>点我下载</strong></a></p>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>Vue前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理</title>
    <url>/2023/05/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>数据库系统原理实验&amp;&amp;作业</p>
<span id="more"></span>



<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A2%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0.docx">作业二：数据操作语言：SQL</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A%E4%B8%89.docx">作业三：数据库安全性、数据库完整性</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A5%EF%BC%9A%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%AC%AC%E5%8D%81%E7%AB%A0.docx">作业五：数据库编程，并发控制与恢复</a></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E5%AD%A6%E7%94%9F%E9%80%89%E8%AF%BE%E6%88%90%E7%BB%A9-csv%E8%A1%A8%E6%A0%BC-%E5%8F%AF%E5%AF%BC%E5%85%A5workbanch.zip">前两次实验数据包，可直接导入workbanch</a></p>
<h3 id="数据库系统原理实训大作业"><a href="#数据库系统原理实训大作业" class="headerlink" title="数据库系统原理实训大作业"></a>数据库系统原理实训大作业</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E3%80%8B%E7%BB%BC%E5%90%88%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%AE%AD.zip">综合实训相关题目和实训报告</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E9%9B%B6%E5%94%AE%E9%9B%86%E5%9B%A2%E5%95%86%E5%93%81%E9%87%87%E8%B4%AD-%E5%AE%9E%E8%AE%AD%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%88%E8%87%AA%E5%88%B6%EF%BC%89.zip">零售集团商品采购数据包</a></p>
<p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E9%9B%B6%E5%94%AE%E9%9B%86%E5%9B%A2%E5%95%86%E5%93%81%E9%87%87%E8%B4%ADER%E5%9B%BE%EF%BC%88%E8%87%AA%E7%BB%98%EF%BC%89.jpg">零售集团商品采购ER图</a></p>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>数据库系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C语言char读入中文</title>
    <url>/2023/05/28/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80char%E8%AF%BB%E5%85%A5%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<p>关于C语言char读入中文</p>
<span id="more"></span>

<p>先上代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> token;</span><br><span class="line"><span class="type">char</span> *src;</span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    token = *src++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上述代码所示，其中<code>token</code>是<code>int</code>类型，而<code>src</code>是<code>char</code>类型的指针，它所指向的内容只会取一个字节进行解析。</p>
<p>现在让<code>src</code>指向一个内存块，其存储的值是<code>0xE4BDA0</code>，即中文字符<code>你</code>的<code>utf-8</code>的编码，由于你的编码占了三个字节，而C语言中<code>char</code>类型只解析一个字节，因此，当<code>src</code>指向这个内存块的时候，只解析最低位，即<code>0xA0</code>。当讲0xA0赋值给token时，因为token是int类型，因此token会将最低位写入0xA0，其它位保持赋值时刷新的值。</p>
<blockquote>
<p>解释一下<code>保持赋值时刷新的值</code>是什么意思：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k;</span><br><span class="line">k=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，k被赋值三，且之前没初始化，那么在赋值时，为了保证k 的正确，应该将对应的内存刷新成二进制</p>
<p><code>0000 0000 0000 0011</code>但是在计算机内部，整数是用补码存储的，因此在计算机中，真实的值应该是</p>
<p><code>0111 1111 1111 1101</code>因为k是int类型，不是无符号，所以第一位仍然是0，表示该数是正数。</p>
</blockquote>
<p>所以，在将0xA0赋值给int时，会经历这样一个过程：</p>
<blockquote>
<p>①判断0xA0在char中是负数：<code>1010 0000</code> 首位是1，判断为负数</p>
<p>②赋值时，计算机为了保证正确性，先将token定义为负数，即首位为1</p>
<p>③确定正负后，将值写入。</p>
</blockquote>
<p>所以token在计算机内部应该是 <code>1111 1111 1111 1010 0000</code> 这是补码形式，转换成真实值就是</p>
<p> <code>1000 0000 0000 0110 0000</code> 所以输出就是<code>-96</code>。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2023/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>计算机网络</p>
<span id="more"></span>

<h3 id="计算机网络作业四：网络层"><a href="#计算机网络作业四：网络层" class="headerlink" title="计算机网络作业四：网络层"></a>计算机网络作业四：网络层</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%BD%91%E4%BD%9C%E4%B8%9A4.pdf">戳我下载！！</a></p>
<h3 id="计算机网络实验四：网际控制报文协议ICMP分析"><a href="#计算机网络实验四：网际控制报文协议ICMP分析" class="headerlink" title="计算机网络实验四：网际控制报文协议ICMP分析"></a>计算机网络实验四：网际控制报文协议ICMP分析</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP%E5%88%86%E6%9E%90.docx">怼我下载计网实验四：网际控制报文协议ICMP分析</a></p>
<h3 id="计算机网络作业五：传输层"><a href="#计算机网络作业五：传输层" class="headerlink" title="计算机网络作业五：传输层"></a>计算机网络作业五：传输层</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%BD%91%E4%BD%9C%E4%B8%9A5.pdf">戳我下载！</a></p>
<h3 id="思政作业3"><a href="#思政作业3" class="headerlink" title="思政作业3"></a>思政作业3</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E6%94%BF%E4%BD%9C%E4%B8%9A3.docx">阅读参考《中国互联网络发展状况统计报告（第51次）》有关内容</a></p>
<h3 id="作业6：应用层"><a href="#作业6：应用层" class="headerlink" title="作业6：应用层"></a>作业6：应用层</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E4%BD%9C%E4%B8%9A6.pdf">作业6666666666：应用层</a></p>
<h3 id="实验六：超文本传送协议HTTP分析"><a href="#实验六：超文本传送协议HTTP分析" class="headerlink" title="实验六：超文本传送协议HTTP分析"></a>实验六：超文本传送协议HTTP分析</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9A%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEHTTP%E5%88%86%E6%9E%90.docx">点我，解锁更多* * *%@#&amp;￥%！@￥%……@#￥</a></p>
<h3 id="实验七：web页面请求全历程协议及数据包解析"><a href="#实验七：web页面请求全历程协议及数据包解析" class="headerlink" title="实验七：web页面请求全历程协议及数据包解析"></a>实验七：web页面请求全历程协议及数据包解析</h3><p><a href="https://gitee.com/pi_haoxuan/pi_haoxuan/releases/download/downloadFile1.0/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E4%B8%83%EF%BC%9Aweb%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E5%85%A8%E5%8E%86%E7%A8%8B%E5%8D%8F%E8%AE%AE%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%A3%E6%9E%90.docx">嘿 嘿嘿 嘿嘿嘿 你懂的</a></p>
<p>END</p>
]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>计网作业</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言解释</title>
    <url>/2023/05/22/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>关于C语言中一些系统定义的解释</p>
<span id="more"></span>

<h3 id="perror-char"><a href="#perror-char" class="headerlink" title="perror( char )"></a>perror( char )</h3><blockquote>
<p>作用：输出错误信息</p>
<p>参数解释：传入字符串，例如<code>perror(&quot;upper&quot;)</code></p>
<p>标准输出：<code>upper: error message</code> 其中error message 是系统定义的错误信息</p>
<p>在写代码是可以适当使用该函数，用来调试程序，函数会指出错误原因</p>
</blockquote>
<h3 id="stderr"><a href="#stderr" class="headerlink" title="stderr"></a>stderr</h3><blockquote>
<p>作用：输出文件处理时候的错误信息</p>
<p>注意：这个不是函数，而是一个指针，类型为<code>FILE*</code>，作为<code>fprintf</code>中的第一个参数使用，后接错误信息</p>
<p><code>code01</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> err_code = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error occurred, error code is %d\n&quot;</span>, err_code);</span><br><span class="line">  <span class="keyword">return</span> err_code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该参数只处理文件操作错误的信息</p>
</blockquote>
<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><blockquote>
<p>作用：C语言中的一个关键词，用于修饰一个函数，放在函数返回类型前。</p>
<p>被修饰的函数称为“<code>内联函数</code>”，通常是一个小巧的，轻量级的函数，定量来看，一般不超过10行。</p>
<p>注意：函数中应该不包括<code>递归</code>、<code>循环</code>等“非轻量级”的操作，或者是一些本身就很复杂的库函数中的函数调用。</p>
<p>作为函数，肯定是常用的，才会封装成一个函数，使得代码简洁，但是这个<code>inline函数</code>看起来好像没啥实际上的作用，那为什么还要用这个关键词修饰呢？</p>
<p>深层内涵：<code>inline</code>函数在编译的时候，会出现在任何一个调用它的地方，并且以内容的形式出现，而不是以跳转地址的形式出现，即函数执行到了调用<code>inline</code>函数的时候，并不需要跳转寻址来另外开栈执行函数，然后再跳转回去继续执行；而是直接将函数内容嵌入调用<code>inline</code>函数的地方，让程序直接往下执行，举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> c = a+b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%D&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    add(a,b);</span><br><span class="line">    add(m,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很简单的加法函数，在<code>main</code>函数中调用了<code>add</code>函数，但是在编译过后，它完全等价于下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> c = a+b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);</span><br><span class="line">    <span class="type">int</span> d = m+n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即将函数以内容的方式呈现在<code>main</code>函数中，而不是以地址跳转的方式去调用函数。</p>
<p>好处：这样一个关键词的存在不仅满足了代码的简洁性和可读性，还可以增加代码的编译速度，在编译和执行的过程中不必另开空间去编译执行。但是如果<code>inline</code>修饰稍稍复杂一点的函数，那会导致汇编代码太长，反而减慢了编译执行的速度，适得其反。所以<code>inline</code>函数只能修饰轻量级函数，而不修饰复杂函数。简而言之<strong>复杂不了一点</strong>。</p>
</blockquote>
<h3 id="strcmp和strncmp"><a href="#strcmp和strncmp" class="headerlink" title="strcmp和strncmp"></a><code>strcmp</code>和<code>strncmp</code></h3><blockquote>
<p>共同点：两者都是比较两个字符串，判断<code>str2</code>是否存在于<code>str1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncmp</span>(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2, <span class="type">size_t</span> n)</span><br></pre></td></tr></table></figure>

<p>可以看到<code>strncmp</code>多了一个参数<code>n</code>，用于限定比较字符的长度，在限定长度内如果相等，则返回<code>0</code>以表示相等，否则返回下标为<code>n</code>的两个字符串的差（str1[n] - str2[n]）</p>
<p>而<code>strcmp</code>是两个字符串全部相等才会返回<code>0</code></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="built_in">strcmp</span>(str1,str2); <span class="comment">//判断结果为不相等</span></span><br><span class="line"><span class="built_in">strncmp</span>(str1,str2,<span class="number">4</span>); <span class="comment">//判断结果为相等</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="stat结构体和stat函数"><a href="#stat结构体和stat函数" class="headerlink" title="stat结构体和stat函数"></a><code>stat</code>结构体和<code>stat</code>函数</h3><blockquote>
<p><code>stat</code>结构体：存储文件信息的一个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">__dev_t</span> st_dev; <span class="comment">/* Device.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __x86_64__</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> __pad1;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __x86_64__ || !defined __USE_FILE_OFFSET64</span></span><br><span class="line">    <span class="type">__ino_t</span> st_ino; <span class="comment">/* File serial number.	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__ino_t</span> __st_ino; <span class="comment">/* 32bit file serial number.	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __x86_64__</span></span><br><span class="line">    <span class="type">__mode_t</span> st_mode;   <span class="comment">/* File mode.  */</span></span><br><span class="line">    <span class="type">__nlink_t</span> st_nlink; <span class="comment">/* Link count.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__nlink_t</span> st_nlink; <span class="comment">/* Link count.  */</span></span><br><span class="line">    <span class="type">__mode_t</span> st_mode;   <span class="comment">/* File mode.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">__uid_t</span> st_uid; <span class="comment">/* User ID of the file&#x27;s owner.	*/</span></span><br><span class="line">    <span class="type">__gid_t</span> st_gid; <span class="comment">/* Group ID of the file&#x27;s group.*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">    <span class="type">int</span> __pad0;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">__dev_t</span> st_rdev; <span class="comment">/* Device number, if device.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __x86_64__</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> __pad2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __x86_64__ || !defined __USE_FILE_OFFSET64</span></span><br><span class="line">    <span class="type">__off_t</span> st_size; <span class="comment">/* Size of file, in bytes.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__off64_t</span> st_size; <span class="comment">/* Size of file, in bytes.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">__blksize_t</span> st_blksize; <span class="comment">/* Optimal block size for I/O.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __x86_64__ || !defined __USE_FILE_OFFSET64</span></span><br><span class="line">    <span class="type">__blkcnt_t</span> st_blocks; <span class="comment">/* Number 512-byte blocks allocated. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__blkcnt64_t</span> st_blocks; <span class="comment">/* Number 512-byte blocks allocated. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN2K8</span></span><br><span class="line">    <span class="comment">/* Nanosecond resolution timestamps are stored in a format</span></span><br><span class="line"><span class="comment">       equivalent to &#x27;struct timespec&#x27;.  This is the type used</span></span><br><span class="line"><span class="comment">       whenever possible but the Unix namespace rules do not allow the</span></span><br><span class="line"><span class="comment">       identifier &#x27;timespec&#x27; to appear in the &lt;sys/stat.h&gt; header.</span></span><br><span class="line"><span class="comment">       Therefore we have to handle the use of this header in strictly</span></span><br><span class="line"><span class="comment">       standard-compliant sources special.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>    <span class="comment">/* Time of last access.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>    <span class="comment">/* Time of last modification.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>    <span class="comment">/* Time of last status change.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec <span class="comment">/* Backward compatibility.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__time_t</span> st_atime;              <span class="comment">/* Time of last access.  */</span></span><br><span class="line">    <span class="type">__syscall_ulong_t</span> st_atimensec; <span class="comment">/* Nscecs of last access.  */</span></span><br><span class="line">    <span class="type">__time_t</span> st_mtime;              <span class="comment">/* Time of last modification.  */</span></span><br><span class="line">    <span class="type">__syscall_ulong_t</span> st_mtimensec; <span class="comment">/* Nsecs of last modification.  */</span></span><br><span class="line">    <span class="type">__time_t</span> st_ctime;              <span class="comment">/* Time of last status change.  */</span></span><br><span class="line">    <span class="type">__syscall_ulong_t</span> st_ctimensec; <span class="comment">/* Nsecs of last status change.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">    <span class="type">__syscall_slong_t</span> __glibc_reserved[<span class="number">3</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __glibc_reserved4;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __glibc_reserved5;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">__ino64_t</span> st_ino; <span class="comment">/* File serial number.	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中常用的属性段有</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">st_mode：文件类型和权限位</span><br><span class="line">st_ino：文件的i-node号</span><br><span class="line">st_dev：文件所在设备的ID</span><br><span class="line">st_nlink：链接数</span><br><span class="line">st_uid：文件所有者的用户ID</span><br><span class="line">st_gid：文件所有者的组ID</span><br><span class="line">st_size：文件大小（字节数）</span><br><span class="line">st_atime：最后一次访问时间</span><br><span class="line">st_mtime：最后一次修改时间</span><br><span class="line">st_ctime：最后一次改变时间（通常是文件元数据改变的时间）</span><br></pre></td></tr></table></figure>

<p>可以极简单地获取文件信息</p>
<p><code>stat</code>函数：用于获取给定路径下的文件的信息，并存储在一个<code>stat</code>结构体中，返回值为<code>int</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get file attributes for FILE and put them in BUF.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">stat</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__restrict __file,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> stat *__restrict __buf)</span> __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若成功获取文件信息，则返回<strong>0</strong> 否则返回<strong>1</strong></p>
</blockquote>
<h3 id="va-list、va-start、va-arg、va-end函数"><a href="#va-list、va-start、va-arg、va-end函数" class="headerlink" title="va_list、va_start、va_arg、va_end函数"></a><code>va_list</code>、<code>va_start</code>、<code>va_arg</code>、<code>va_end</code>函数</h3><blockquote>
<p><code>va_list</code>：可以理解为一种新类型，类似于<code>int</code>。实例化一个类似于<code>list</code>的东西，但是名字是<code>va_list</code>。</p>
<p><code>va_start</code>：函数使用：<code>va_start(va_list n, paramN)</code>。</p>
<p>初始化一个<code>va_list</code>实例，<code>paramN</code>可以是任意参数，即初始化<code>n</code>以检索参数<code>paramN</code>以后的参数，通常<code>paramN</code>是指<code>paramN</code>之后的参数个数</p>
<p><code>va_arg</code>：函数使用：<code>va_arg(va_list n , T)</code></p>
<p>获取va_list n 中的<code>T</code>类型的参数，通常是从<code>paramN</code>之后的一个参数开始获取的（包含<code>paramN</code>之后的那个参数，但不包括<code>paramN</code></p>
<p>va_end：函数使用：va_end(va_list n)</p>
<p>释放<code>va_list n</code></p>
<p>函数示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明，可以传入任意多个参数，但第一个参数必须是int</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//3个int相加，分别是 15， 56， 4</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Sum = %d\n&quot;</span>,  sum(<span class="number">3</span>, <span class="number">15</span>, <span class="number">56</span>,<span class="number">4</span>) );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num_args, ...)</span> &#123;</span><br><span class="line">   <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例化一个va_list ap</span></span><br><span class="line">   va_list ap;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   va_start(ap, num_args);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_args; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i:%d\n&quot;</span>,i);</span><br><span class="line">    <span class="comment">//获取第一个int参数（是除了paramN之后的第一个，在本函数中也就是num_args后面的一个参数）</span></span><br><span class="line">    <span class="comment">//如果有参数不是int，则自动获取下一个，但是如果后面没有参数了，就会获取随机值</span></span><br><span class="line">    s=va_arg(ap,<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;va_arg(ap,int):%d\n&quot;</span>,s);</span><br><span class="line">       </span><br><span class="line">     <span class="comment">//累加</span></span><br><span class="line">     val += s;</span><br><span class="line">   &#125;</span><br><span class="line">   va_end(ap);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述函数中，需要用s变量承接va_arg(ap,int)是因为va_arg函数每调用一次，获取玩当前的值后会自动往后走，下次调用的时候可以直接获取，然后再往下走。</span></span><br></pre></td></tr></table></figure>

<p>说明：这四个通常是一套组合拳，而且用于自定义的函数中，通常不作为单独的函数被调用，而是处理自定义的函数传入的参数。</p>
<p>例如，上述例子中，定义的<code>sum</code>函数，可以接收任意多个参数，于是就是用这一套组合拳，处理这任意多的参数。</p>
<p>值得一提的是，<code>va_arg()</code>函数是处理任意多参数的关键，它能获取<code>sum</code>函数中第一个参数之后的所有参数（调用一次获取一次，并自动会跳到下一个参数【如果没有下一个，就是随机值】），并自动识别停止。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>编译学习-虚拟机部分--20230518</title>
    <url>/2023/05/18/%E7%BC%96%E8%AF%91%E5%AD%A6%E4%B9%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E5%88%86-20230518/</url>
    <content><![CDATA[<p>编译学习虚拟机部分</p>
<span id="more"></span>

<h3 id="1、支撑知识"><a href="#1、支撑知识" class="headerlink" title="1、支撑知识"></a>1、支撑知识</h3><h4 id="关于电脑内存"><a href="#关于电脑内存" class="headerlink" title="关于电脑内存"></a>关于电脑内存</h4><p>电脑中的内存是虚拟地址映射到实际的内存上，而非真是有这么多。</p>
<h4 id="关于本次使用的内存段"><a href="#关于本次使用的内存段" class="headerlink" title="关于本次使用的内存段"></a>关于本次使用的内存段</h4><p>简单来讲，进程的内存会被分为以下几个段</p>
<blockquote>
<p>1.代码段（text），用于存放指令代码，位于较低地址。（可能是指令需要改动不多甚至不需要改动，放在一些低地址区域，该区域可能是只读的）</p>
<p>2.数据段（data），用于存放<strong>已经初始化的数据</strong>，例如<code>int i = 10</code>就是已经初始化的数据，需要存储到改位置。</p>
<p>3.未初始化数据段（bss），顾名思义，就是存放<strong>未初始化的数据</strong>的地方，例如<code>int i[1000]</code>就是属于只声明而未初始化的数据，存放在该段。</p>
<p>4.堆（heap），用于为程序动态分配内存。</p>
<p>5.栈（stack）用于处理函数调用的相关数据，例如调用帧或者函数的局部变量。</p>
</blockquote>
<p>在第一点中提到在代码段在内存中位于低地址区域，那么如下图所示：</p>
<p><code>图一</code></p>
<p><img src="/2023/05/18/%E7%BC%96%E8%AF%91%E5%AD%A6%E4%B9%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E5%88%86-20230518/%E5%9C%B0%E5%9D%80%E5%88%86%E5%B8%83.jpg" alt="各部分地址分布"></p>
<p>个人理解：在计算机内存中，低地址是不允许写入的，其中存放的数据都是一些系统级的或者是常量，例如数字（0-9），字符（a-zA-Z,.&#x2F;等），当程序需要时，就只能读取而不能写入。</p>
<p>而在高地址字段，例如堆栈，可以实现内存的动态分配和数据的调用和修改，即可读可写，提高了与用户的交互性。</p>
<p>为简单起见，本次只关心 <strong>①代码段 ②数据段 ③栈</strong></p>
<h4 id="③寄存器"><a href="#③寄存器" class="headerlink" title="③寄存器"></a>③寄存器</h4><p>寄存器用于存放计算机的运行状态，真实计算机中有许多寄存器，本次只用4种。</p>
<blockquote>
<p>1.<code>PC（Program Counter）程序计数器</code> 存放内存地址，该地址中放着<strong>下一条</strong>要执行的计算机指令</p>
<p>2.<code>SP（Stack Pointer）指针寄存器</code> 永远指向当前栈的栈顶。因为栈顶是由高地址扩张到低地址（可以参考图一，栈底在最顶端）所以当有数据入栈时，SP的地址值减小；当出栈时SP的地址值增大</p>
<p>3.<code>BP（Base Pointer）基址指针</code> 也是用于指向栈的某些位置（不想确定的位置，也并不是不能指向栈顶）</p>
<p>4.<code>AX（Accumulator Register）通用寄存器</code> 从英文上看出是累加寄存器，在虚拟机中，用于存放一条指令执行后的计算结果。</p>
<p><strong>PS：前三个都是存放地址的，定义是要指针定义，而AX是存放结果的，不用定义成指针。在实际计算机中，PC的初始值应该指向main函数的地址，但是现在 还没到这一步，先不指定。</strong></p>
</blockquote>
<h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>可不可以用unsigned int？？？</p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><h4 id="类型问题"><a href="#类型问题" class="headerlink" title="类型问题"></a>类型问题</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LC)   &#123;ax = *(<span class="type">char</span> *)ax;&#125;      <span class="comment">// load character to ax, address in ax</span></span><br></pre></td></tr></table></figure>

<p>if中的操作是将ax中的值作为地址，并且按照char类型解析该地址指向的内容，然后将解析完后的char重新赋值给ax，应该会导致类型冲突的呀。</p>
<blockquote>
<p><strong>解答</strong>：在计算机内存中，不论是<code>int</code>还是<code>char</code>还是各种指针类型，其实都是一个数，而<code>int</code>，<code>char</code>或者是<code>int*</code>，<code>char*</code>是决定程序在解析这个数的时候的方式（往后读多少个内存单元，按照什么类型解析）。</p>
<p>改代码中，如果ax不是很大的数（8位以内），可以正常运行，再大就会出现转换错误的情况。</p>
</blockquote>
<h4 id="sp-sp-pc"><a href="#sp-sp-pc" class="headerlink" title="sp = sp - *pc++"></a><code>sp = sp - *pc++</code></h4><p>将栈顶指针sp 减去下一个指令需要使用的空间大小，pc++是指下一个指令的地址，解引用后就是指下一个指令，同时是一个int值，为什么指的是下一个指令所需要的空间大小？</p>
<blockquote>
<p><strong>解答</strong>：在函数调用时，一个函数需要多大的空间运行，一般都会在函数内部用一个小空间存储这个内容。</p>
<p>这里将这个内容取出来减去，就是回收之前为子函数开辟出来的子函数提前告知的需要的空间。</p>
</blockquote>
<h3 id="TIPS："><a href="#TIPS：" class="headerlink" title="TIPS："></a>TIPS：</h3><h4 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h4><p><code>int * </code>和<code>char *</code>本质上都是指针，而指针都是一个数字，而计算机内指针都是用数字表示的，为什么不统一用int或者是unsigned int，而是要分int char和其它？</p>
<p>因为<code>int * </code>和<code>char *</code>指向的数字表示不同的数据类型，而且还是做指针运算时的重要依据，比如在int类型中，指针运算++是向后移动4个字节（大多数机器是这样的），而char类型在做指针运算时，往往只向后移动1个字节，计算机做出这样的依据就是所使用的指针类型。</p>
<p>其次，在计算机编译阶段，这两种类型对应存储的数据需要不同，计算机在编译时会检查<code>int * </code>和<code>char *</code>所指向的数据是否正确，若不正确则报错，避免潜在的错误。</p>
<p>GPT这样说：</p>
<blockquote>
<p>int *和char *在本质上的区别是指针所指向内存单元中存储的数据类型不同。</p>
<p>int * 是一个指向整型变量的指针，它所指向的内存单元中存储的是一个整型数值，占用 4 字节（在大部分机器上）。而 char * 则是一个指向字符型变量的指针，它所指向的内存单元中存储的是一个字节大小的 ASCII 码或者 Unicode 码。</p>
<p>在计算机编译时，int <em>和char * 在指针操作上会有所不同。在执行指针运算时，指针所指向的内存单元地址将根据数据类型的不同而发生改变。例如，对于一个 int</em> 指针变量 p，执行 p++ 操作时，p 的值将增加 4，因为一个 int 变量占用 4 个字节。而对于一个 char* 指针变量 q，执行 q++ 操作时，q 的值只会增加 1，因为一个 char 变量只占用一个字节。</p>
<p>此外，在编译器生成目标代码时，对于 int * 和 char * 所指向的内存单元，编译器在生成代码时还会进行类型检查。这是为了确保程序不会访问不正确的内存地址，避免潜在的错误。例如，在使用 int * 指针时，我们只能访问整型变量的内存地址，不能访问 char 或其他类型变量的内存地址。</p>
</blockquote>
<h4 id="关于栈顶"><a href="#关于栈顶" class="headerlink" title="关于栈顶"></a>关于栈顶</h4><p><code>SP指针寄存器</code> 永远指向当前栈的栈顶  此处的栈顶是最顶端的元素，而非最顶端元素的上面一个。</p>
<h4 id="一些骚操作"><a href="#一些骚操作" class="headerlink" title="一些骚操作"></a>一些骚操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SC)   &#123;ax = *(<span class="type">char</span> *)*sp++ = ax;&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的运算顺序是：</p>
<p>①sp++申请新空间</p>
<p>②*解引用</p>
<p>③将ax的值存进去</p>
<p>④char * 强转</p>
<p>⑤*解引用</p>
<p>⑥将值再赋给ax（如果ax中的数字小的话，其实没变）</p>
<h4 id="pc-1和-int-pc"><a href="#pc-1和-int-pc" class="headerlink" title="pc+1和(int *)*pc"></a><code>pc+1</code>和<code>(int *)*pc</code></h4><p><code>pc = pc+1</code>是指顺序执行下一行代码（从上帝视角来看）</p>
<p><code>pc = (int *) *pc</code>是指跳转到下一个语句块</p>
<p>从JMP指令的实现是<code>pc = (int *) *pc</code>就能看出，如果if后面是0，那么则回执行<code>pc = (int *) *pc</code>，实质上是进行了一次JMP。</p>
<h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>编译设计</title>
    <url>/2023/05/12/%E7%BC%96%E8%AF%91%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>着手设计</p>
<span id="more"></span>

<h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>学习<strong>手把手教你构建C语言编译器–设计</strong>部分</p>
<p><a href="https://lotabout.me/2015/write-a-C-interpreter-1/">手把手教你构建 C 语言编译器（1）- 设计 </a></p>
<p>试写了文章中的代码，虽然成功了，但是有点问题。</p>
<h4 id="2、概念"><a href="#2、概念" class="headerlink" title="2、概念"></a>2、概念</h4><p>编写一个编译器一般为<strong>①词法分析器；②语法分析器；③目标代码生成</strong>。以下为手写这些构成部分。</p>
<p>一个编译器的框架首先是有</p>
<blockquote>
<p>编译器包含四个函数：</p>
<p>1、next()函数，用于读取下一个标记，会自动忽略掉空格；	&#x2F;&#x2F;读程序</p>
<p>2、program()函数，语法分析的入口，分析整个程序。本部分不写；	&#x2F;&#x2F;做语法分析</p>
<p>3、expression(level)函数，用于解析一个表达式。本部分不写；	&#x2F;&#x2F;做语义分析</p>
<p>4、eval()函数，虚拟机接口，可以解释目标代码。</p>
</blockquote>
<h4 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h4><p>以下是代码块，和教程上的代码一模一样，，，，，</p>
<p><code>code01</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> token;</span><br><span class="line"><span class="type">char</span> *src, *old_src;</span><br><span class="line"><span class="type">int</span> poolsize;</span><br><span class="line"><span class="type">int</span> line;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取src中下一个字符的ASCII码值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    token = *src++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式分析pewpwd</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expression</span><span class="params">(<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取文件，直到token小于0（因为token是ASCII，所以没有小于0 的情况，等于0就是结束符）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    next(); <span class="comment">// get next token</span></span><br><span class="line">    <span class="keyword">while</span> (token &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;token is: %c\n&quot;</span>, token);</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机接口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">eval</span><span class="params">()</span></span><br><span class="line">&#123; <span class="comment">// do nothing yet</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, fd;</span><br><span class="line"></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    poolsize = <span class="number">256</span> * <span class="number">1024</span>; <span class="comment">// arbitrary size</span></span><br><span class="line">    line = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(*argv, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;could not open(%s)\n&quot;</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(src = old_src = <span class="built_in">malloc</span>(poolsize)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;could not malloc(%d) for source area\n&quot;</span>, poolsize);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the source file</span></span><br><span class="line">    <span class="keyword">if</span> ((i = read(fd, src, poolsize - <span class="number">1</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read() returned %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    src[i] = <span class="number">0</span>; <span class="comment">// add EOF character</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、问题"><a href="#4、问题" class="headerlink" title="4、问题"></a>4、问题</h4><p>①第三行 include 的 memory.h 好像没用到（可能之后会用到吧）</p>
<p>②第52行，open函数中的参数，第一个参数是取用户输入的第一个参数，但是第二个参数不理解。</p>
<p>翻看了函数原型，代码如下：</p>
<p><code>code02</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__fortify_function <span class="type">int</span></span><br><span class="line"><span class="title function_">open</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__path, <span class="type">int</span> __oflag, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__va_arg_pack_len () &gt; <span class="number">1</span>)</span><br><span class="line">    __open_too_many_args ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_constant_p (__oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__OPEN_NEEDS_MODE (__oflag) &amp;&amp; __va_arg_pack_len () &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  __open_missing_mode ();</span><br><span class="line">	  <span class="keyword">return</span> __open_2 (__path, __oflag);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">return</span> __open_alias (__path, __oflag, __va_arg_pack ());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__va_arg_pack_len () &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> __open_2 (__path, __oflag);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __open_alias (__path, __oflag, __va_arg_pack ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数是int类型没错，但是具体含义不知道。</p>
<p>上网查后，解释是，第二个参数代表对该文件的操作权限，例如：只读，只写，读写。但是很神奇，这些权限的表示方法如下：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">flags 参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O_RDONLY</td>
<td align="center">只读模式</td>
</tr>
<tr>
<td align="center">O_WRONLY</td>
<td align="center">只写模式</td>
</tr>
<tr>
<td align="center">O_RDWR</td>
<td align="center">可读可写</td>
</tr>
<tr>
<td align="center">O_APPEND</td>
<td align="center">表示追加，如果原来文件里面有内容，则这次写入会写在文件的最末尾</td>
</tr>
<tr>
<td align="center">O_CREAT</td>
<td align="center">表示如果指定文件不存在，则创建这个文件</td>
</tr>
<tr>
<td align="center">O_EXCL</td>
<td align="center">表示如果要创建的文件已存在，则出错，同时返回 -1，并且修改 errno 的值</td>
</tr>
<tr>
<td align="center">O_TRUNC</td>
<td align="center">表示截断，如果文件存在，并且以只写、读写方式打开，则将其长度截断为0</td>
</tr>
</tbody></table>
</blockquote>
<p>如表所示，并没有数字，不理解。。。。。。</p>
<blockquote>
<p><strong>解答</strong>：这些flags参数是在一个枚举类型中的常量，如下代码所示：</p>
<p><code>code03</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    O_RDONLY,   <span class="comment">// 只读打开</span></span><br><span class="line">    O_WRONLY,   <span class="comment">// 只写打开</span></span><br><span class="line">    O_RDWR,     <span class="comment">// 读写打开</span></span><br><span class="line">    O_APPEND,   <span class="comment">// 追加方式打开</span></span><br><span class="line">    O_CREAT,    <span class="comment">// 若文件不存在，则创建该文件</span></span><br><span class="line">    O_EXCL,     <span class="comment">// 与O_CREAT一同使用，如果文件已经存在则出错</span></span><br><span class="line">    O_TRUNC,    <span class="comment">// 截断文件长度为0</span></span><br><span class="line">    O_NOCTTY,   <span class="comment">// 不要把设备用作控制终端</span></span><br><span class="line">    O_NONBLOCK, <span class="comment">// 非阻塞模式</span></span><br><span class="line">    O_SYNC      <span class="comment">// 同步方式打开</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码就是一个枚举类型（包括之后的指令集也是枚举类型），从第一个到最后一个按照自然数（0或许不是自然数？）顺序排列，比如<code>O_RDONLY</code>就是<code>0</code>，以此类推。。。</p>
</blockquote>
<p>③当我运行这个文件时，即执行下列命令</p>
<p><code>code04</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$$ gcc 01.c -o 01</span><br><span class="line">$$$ ./01 01.c</span><br></pre></td></tr></table></figure>

<p>逐个字符读取只读到了第11行的&#x2F;&#x2F;和其后的一个空格，程序就中止了，不知道为什么。。。。。。</p>
<p>开始觉得是因为后面是中文字符，于是在“读取”前面随便加了几个字母，发现读取成功，但是<strong>将后面的所有中文语句换成英文之后又行不通了</strong></p>
<p>又试了一下，一读到注释就不行了。</p>
<blockquote>
<p><strong>解答</strong>：其实就是字符问题，因为在<code>next</code>函数中，读的是字符的ASCII码值，而中文字符在ASCII中是没有位置的，因此读不下去了，所以文件中避免出现中文。</p>
<p>其原理是，读取函数根据数据类型（其实所有的都是这样的）决定本次读取往后读多少个字节单位，而char只有一个字节，但是中文字符占两个或者三个字节（根据编码不同而相异），因此不能继续读下去</p>
<p>如果将第28行中的<code>token &gt; 0</code>改成<code>token != EOF</code>就可以成功读完文件，但是对应的中文都是乱码，而且由于前面中文出现了“断章取义”的现象，后面的英文大概率也是乱的。</p>
<p>还有一个方法就是用wchar类型，也就是将第7行的<code>src</code>和<code>old_src</code>定义为<code>wchar*</code>类型，这样就可以正常读中文了。</p>
</blockquote>
<h4 id="5、TIPS"><a href="#5、TIPS" class="headerlink" title="5、TIPS"></a>5、TIPS</h4><p>①先看第64行，src里面是读取的文件内容，和第69行联系起来看，第69行在 i 的位置加了个0，即为封口。于是 i 的值就有点耐人寻味了。</p>
<blockquote>
<p>read 函数 返回值有三种情况。</p>
<p>1、读取出错，返回-1，即有如果 i 小于 0 ，那么直接print错误</p>
<p>2、读取时，未达到第三个参数设置的大小就读完了。这是最正常的情况。此时返回的 i 就是大于0且小于第三参数。且为已经读到的字节数。（个人理解为就是EOF的下标，后面才可以在 i 处封口）</p>
<p>3、读取时，文件大小超过第三参数大小，即没读完就读不下了，这时返回的仍然是已经读取到的字节数，但是比较特殊，其值等于第三参数。</p>
</blockquote>
<p>除了读取错误返回-1，其余两种情况都进行了封口操作，即便有一种情况是强制封口。</p>
<p>②从51行开始，到55行，其实做了两件事：第一、open文件；第二、判断错误，如果文件描述符fd小于0，那么打开文件错误。</p>
<blockquote>
<p>文件描述符返回值：成功则返回0，失败返回-1</p>
</blockquote>
<p>同理，先两个if代码块也是如此，先进行相关操作，再判断操作是否错误</p>
<p>任何错误都将直接返回-1</p>
<p>③next() 函数中 token 读取的其实是ASCII码值，并且通过地址将值带出。</p>
<p>④第46、47行，有个argc- -和argv++</p>
<blockquote>
<p>argc- - 意思是将参数减少。通过查资料可以知道，main函数自带的两个参数其实是本程序的输入参数个数（argc）和输入的参数构成的数组（argv）。值得注意的是，这两个参数都包含他们自己。所以argc初始值就是2，agrv[0]初始值是2，argv[1]初始值是argv（即首地址）</p>
</blockquote>
<p>运行时要解析命令，先把第一个用户输入参数去掉，argc- -，因为第一个往往是调用编译程序的参数，当调用到正确文件时，就不需要第一个参数了。</p>
<p>argv++是地址++，就是跳转到下一个命令参数，然后给程序读取，执行相应操作。</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>20230509（混账版）</title>
    <url>/2023/05/09/20230509/</url>
    <content><![CDATA[<p>混账版</p>
<span id="more"></span>

<p>昨天没写，今天也混账</p>
<p>都是水！！</p>
<p>准备签证资料，烦得很</p>
<p>装好了Ubuntu20.04版本，如果有些button显示不全，就是分辨率的问题，如果输入法奇怪，去设置里面把全屏和双拼换一下，换成微软的输入法，其它都还可以。Ubuntu比Windows好用。</p>
<p>操作系统，恶补</p>
<p>无</p>
<p>END</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title>龙书的散件</title>
    <url>/2023/05/07/20230507/</url>
    <content><![CDATA[<p>龙书的皮屑</p>
<span id="more"></span>

<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>挺有意思的。</p>
<h5 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h5><p>在C语言中，代码的作用域是通过一对花括号**{}<strong>来决定的，一个花括号包围起来的部分叫做一个</strong>块<strong>而且C语言支持块的嵌套，这种嵌套特性叫做</strong>块结构**。</p>
<p>例如下面的代码</p>
<p><code>code scope1</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a  =<span class="number">3</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在任何编译器上执行，执行结果一定是如下图所示</p>
<img src="/2023/05/07/20230507/scope.jpg" alt="scope" style="zoom:150%;">

<p>第11行中的 a 是第10行的 a ，并且，观察第九行和第十位行，得知，a &#x3D; 3只在这个区域有效，而在此之前，观察第八行 int b &#x3D; 2，也只在第七行的 { 和第十八行的 } 之间有效。因此，最后一次的输出结果正是最初定义的数值。以此类推也就不难理解作用域了。</p>
<p>例如Java语言，定义了关键字来表示一个或者一些成员变量的作用域。其中<strong>private</strong>表示私有的，即只有该类能够访问该成员变量；<strong>protected</strong>表示被保护的，即该类及其子类可以访问；<strong>public</strong>表示公共的，即不论在程序的哪个部分都可以访问。</p>
<h5 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h5><p>如果说例如<code>code scope1</code>中的代码，编译器在编译阶段就可以确定某个变量的值，那么可以将这些变狼的作用域叫做静态作用域。那么相应的还有动态作用域。即程序在编译时刻并不知道这个变量到底什么时候有，或者在这个地方代表什么值。</p>
<p><code>code scope2</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> a (x + 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x =<span class="number">1</span>;  </span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码块<code>code scope2</code>中，先宏定义了一个a，且值等于x+1，但是并不知道x在哪，x的值是多少。</p>
<p>在函数f1中，重新定义了x &#x3D; 1，因此，x &#x3D; 1作用域只在f1中有效，所以输出结果是____;在函数f2中，并没有重新定义x，因此x还是全局定义时的2，所以输出结果是____。</p>
<h4 id="函数传参机制"><a href="#函数传参机制" class="headerlink" title="函数传参机制"></a>函数传参机制</h4><p>函数传参大多数无非使用两种机制<strong>值调用</strong>和<strong>引用调用</strong>。涉及到<strong>形式参数（形参）</strong>和<strong>实在参数（实参）</strong></p>
<h5 id="值调用"><a href="#值调用" class="headerlink" title="值调用"></a>值调用</h5><p>在调用时，内部处理对实参进行拷贝，将拷贝的值放在函数中进行处理，但是在主函数中，依旧是原来的值。可以简单地理解为，对实参的<strong>盗版</strong>进行了一系列处理，但是对正版没做出任何处理，在实际使用中依旧是使用正版。</p>
<p>但是在C语言中，我们可以传一个变量的指针进函数，虽然也是对传进去的值进行拷贝后处理，但是传原来的指针和拷贝后的指针都指向同一个内存区域，即同一个值，如果对该值做出处理。那么原来的值也会相应改变。</p>
<p>还有一种方法，我们可以将值return出来，但是，其实也不改变之前按变量的值，只是return出来的值变了。</p>
<p><code>code3</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x ++;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x ++;</span><br><span class="line">    <span class="keyword">return</span> x;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span>* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f1</span>(x);</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f2</span>(x)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">f3</span>(&amp;x);</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="引用调用"><a href="#引用调用" class="headerlink" title="引用调用"></a>引用调用</h5><p>引用调用其实就是将需要调用的参数的地址传到相应函数进行处理。</p>
<p>但是，如果调用的实参时一个表达式，那么，编译器会先将表达式的值计算出来，然后存在自己的位置（另外的位置），改变形参会改变这个位置上的值，但是对调用者的数据没有影响。</p>
<p>友链：<a href="https://blog.csdn.net/m0_37618340/article/details/81070416#:~:text=%E6%8C%89">按值调用和按引用调用</a></p>
<h4 id="TIPS："><a href="#TIPS：" class="headerlink" title="TIPS："></a>TIPS：</h4><p>①声明和定义：声明式告诉我们事物的类型，而定义告诉我们它的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;<span class="comment">//声明</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>

<p>②别名：如果p和q指向同一位置，那么p和q实质上是一样的，则称p是q的别名，或者 q是p的别名。他们之间任一改变都会影响另一个的改变。</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>接上篇</title>
    <url>/2023/05/06/20230506/</url>
    <content><![CDATA[<p>今天学的有点散乱</p>
<span id="more"></span>

<p>上一篇文章：<a href="/2023/05/05/20230505/" title="开始接触编译">开始接触编译</a></p>
<h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>即使用语法树和符号表，检查源程序是否和语言定义的语义一致，同时收集类型信息，将它们放在语法树或者符号表中，后面的中间代码生成中会用到。</p>
<p>同时，在语法树中，自动类型转换可以作为一个单独的节点表示，如下图</p>
<p><img src="/2023/05/06/20230506/cast.jpg" alt="cast"></p>
<p>inttofloat 表示把一个整型转换成一个浮点型。当上述（上篇文章）中的a，b，c都是浮点型时，30必须转换成浮点型才能和它们进行运算，因此发生了自动类型转换。且从低精度到高精度的转换是自然的。</p>
<h4 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h4><p>其实，上述文章中一直在讲的<strong>语法树</strong>已经是一种中间代码了。</p>
<p>中间代码需要满足两点：①<strong>易于生成</strong>     ②<strong>易于被翻译成目标机器的语言</strong></p>
<p>例如<strong>三地址代码</strong></p>
<p>上述表达式<strong>a &#x3D; b + c * 30</strong>可以表示为</p>
<p><code>code1.1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1 = inttofloat(30)</span><br><span class="line">t2 = id3 * t1</span><br><span class="line">t3 = id2 + t2</span><br><span class="line">id1 = t3</span><br></pre></td></tr></table></figure>

<p>上述代码块就是三地址代码。</p>
<p>三地址代码有以下要求：①<strong>赋值指令右侧最多只能有一个运算符</strong>（为了保证运算顺序）；②<strong>编译器应该生成一个临时变量名存放三地址指令计算得到的值</strong>（例如t1,t2,t3）;③<strong>有些三地址代码的运算分量少于三个</strong>（例如上述代码块第1行和第4行）.</p>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>机器无关代码的优化，实质上就是改进中间代码，从而可以生成更好的目标代码（更好意味着执行更快或者功耗更小等等）</p>
<p>比如，上面的三地址代码第一行，可以在编译的时候直接用<strong>30.0</strong>替换<strong>30</strong>，从而避免进行转型运算，中间步骤也可以优化，具体如下</p>
<p><code>code1.2</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1 = id3 * 30.0</span><br><span class="line">id1 = id2 + t1</span><br></pre></td></tr></table></figure>

<h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>即生成目标机器的语言。</p>
<p>中间代码作为代码生成器的输入，映射到目标语言。如果目标机器的目标语言是机器代码，那么就需要合理分配寄存器以存放变量的值。</p>
<p>例如，code1.2 可以被翻译成如下形式</p>
<p><code>code1.3</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDF R2,id3</span><br><span class="line">MULF R2,R2,#30.0</span><br><span class="line">LDF R1,id2</span><br><span class="line">ADDF R1,R2</span><br><span class="line">STF id1,R1</span><br></pre></td></tr></table></figure>

<p><strong>自行理解</strong></p>
<h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p><strong>符号表是一种数据结构</strong>，可以存储变量的各个属性，例如变量的存储分配，变量类型，变量的作用域等等。</p>
<h4 id="趟"><a href="#趟" class="headerlink" title="趟"></a>趟</h4><p>可以将多个步骤组合成一趟。例如前端步骤中的词法分析，语法分析，语义分析以及中间代码生成可以被组合成一趟，而代码优化可以作为一个可选择的趟。还可以有一个为特定目标机器生成代码的后端趟。</p>
<p>可以有不同的前端趟和某个固定的机器后端结合，实现一台机器可以编译多种语言</p>
<p>也可以固定的前端趟和不同的机器后端结合，实现同一语言不同机器编译</p>
<h4 id="编译器构造工具"><a href="#编译器构造工具" class="headerlink" title="编译器构造工具"></a>编译器构造工具</h4><p>顾名思义，就是做编译器的东西</p>
<p>1）语法分析器的生成器：根据某一规则，生成相应的语法分析器</p>
<p>2）扫描器的生成器：根据某一规则，生成相应的扫描器（扫描器也即词法分析器）</p>
<p>3）语法制导的翻译引擎：生成一组用于遍历语法树并生成中间代码的例程（没大懂，抄书的）</p>
<p>4）代码生成器的生成器：根据某些<strong>如何把中间语言翻译成目标机器语言</strong>的规则，生成代码</p>
<p>5）数据流分析引擎：收集数据流信息，即，程序的值如何从程序的一个部分流向另一个部分，可以简单的理解为，函数传参。</p>
<p>6）编译器构造工具集：构造编译器工具的集合      <strong>纯纯废话了</strong></p>
<p>END</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>chatgpt镜像</title>
    <url>/2023/05/06/chatgpt%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>chat_gpt镜像</p>
<span id="more"></span>

<p>尝试注册chatgpt，然后光荣地通过了邮箱验证，光荣地在手机号验证中失败，之前<a href="https://pi_haoxuan.gitee.io/2023/05/06/%E6%B3%A8%E5%86%8CGPT/">blog</a>中提到的虚拟手机号网站试了几十个电话号码，都不行。于是，百般无奈，使用起镜像来，不得不说，有些镜像还是可以的，但是有些镜像就是一坨大便。</p>
<h1 id="如果有与本文章描述不相符的，欢迎大家测试打假，联系方式"><a href="#如果有与本文章描述不相符的，欢迎大家测试打假，联系方式" class="headerlink" title="如果有与本文章描述不相符的，欢迎大家测试打假，联系方式"></a>如果有与本文章描述不相符的，欢迎大家测试打假，<a href="https://pihaoxuan.github.io/about/">联系方式</a></h1><h2 id="镜像链接"><a href="#镜像链接" class="headerlink" title="镜像链接"></a>镜像链接</h2><h4 id="导航："><a href="#导航：" class="headerlink" title="导航："></a>导航：</h4><p><a href="https://lzw.me/x/chatgpt-sites">https://lzw.me/x/chatgpt-sites</a></p>
<p><a href="https://ailink.icu/">https://ailink.icu</a></p>
<p><a href="https://www.ooopn.com/tool/chatgpt">https://www.ooopn.com/tool/chatgpt</a></p>
<p><a href="https://chatgpts.ninvfeng.xyz/">https://chatgpts.ninvfeng.xyz</a></p>
<p><a href="https://cc.ai55.cc/">https://cc.ai55.cc</a></p>
<p><a href="https://github.com/xx025/carrot">https://github.com/xx025/carrot</a></p>
<p><a href="https://github.com/weekend-project-space/chatgpt-sites">https://github.com/weekend-project-space/chatgpt-sites</a></p>
<h3 id="其它常见站点："><a href="#其它常见站点：" class="headerlink" title="其它常见站点："></a>其它常见站点：</h3><h4 id="ChatGPT-4"><a href="#ChatGPT-4" class="headerlink" title="ChatGPT-4:"></a>ChatGPT-4:</h4><p><a href="https://play.vercel.ai/">https://play.vercel.ai</a></p>
<p><a href="https://chat.forefront.ai/">https://chat.forefront.ai</a></p>
<p><a href="https://chatmindai.cn/">https://chatmindai.cn</a></p>
<p><a href="https://poe.com/GPT-4">https://poe.com/GPT-4</a> </p>
<p><a href="https://ora.sh/openai/gpt4">https://ora.sh/openai/gpt4</a></p>
<h4 id="ChatGPt3-5"><a href="#ChatGPt3-5" class="headerlink" title="ChatGPt3.5:"></a>ChatGPt3.5:</h4><p><a href="https://www.phind.com/">https://www.phind.com</a>   【可嵌入vscode中辅助代码编写，网站本身也很好用，不科学的上网是用不了的】</p>
<p><a href="https://dev.yqcloud.top/">https://dev.yqcloud.top</a></p>
<p><a href="http://ai.usesless.com/">http://ai.usesless.com</a>  	【服务器在中国，不用科学上网，但是有敏感词检测且输入字数有限制】</p>
<p><a href="https://freegpt.top/">https://freegpt.top</a></p>
<p><a href="https://freegpt.one/">https://freegpt.one</a></p>
<p><a href="https://chatforai.com/">https://chatforai.com</a></p>
<p><a href="https://chat.theb.ai/">https://chat.theb.ai</a></p>
<p><a href="http://chat.apigpt.cn/">http://chat.apigpt.cn</a></p>
<p><a href="https://trychatgp.com/">https://trychatgp.com</a></p>
<p><a href="https://www.perplexity.ai/">https://www.perplexity.ai</a></p>
<p><a href="https://chat20.yqcloud.top/">https://chat20.yqcloud.top</a></p>
<p><a href="https://poe.com/">https://poe.com</a></p>
<p><a href="https://you.com/">https://you.com</a></p>
]]></content>
      <categories>
        <category>chatgpt</category>
      </categories>
      <tags>
        <tag>chatgpt镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>注册GPT</title>
    <url>/2023/05/06/%E6%B3%A8%E5%86%8CGPT/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c72552f3e25a0e38a120f0908d5a3c1ac084bfeac0856eadde99cde11022f537">4630436162ade97ba2718b7d0c4b3b635b2f6f34676482420dfaf4319505d4d9bd77eafe835cae01bd5c3e58c0d3b506f4be596dfe70a5441afc7e3891e3f64086ff998c55ba3f93e5b6dd0e3afa3b7483c293d51bb389a8e947c92a33bdd28d04195a24b3f525120e555658e21b5a318bd3f2adf36490105faaae17893bb3df6f8662c1c16718ccfbc7f8692d4f08980a1d73f2eaa85d365a298b961b4a907b05f5863d40168993bb22b266c0fa45b6c58bce790895ff8f2011dbc0e5e5be7d9232ece63260910226fc1896e836e6278956d95a82982c8a4d80e18c310ea1c13c40d6f8f7a51c9b4418b9b631ffd4a44de1fe3bc7f11a1bbb8f78048c9a3b2d69284762741398a52ee96c0bdce7dba614be19349459edef52d7d295b596dcbd46a3bfb036fb4f4ffaeb02f80fc932c47313d44e025f1d2ac9e7ec44584fdc20ac07b8c22f091154978108a07be9f21f0093016276691c680a3d618ab7e486fc57537ef532313e16346b6ba9ca33bd3f524232fcdfbcc3000d6e34a201ee25cd5698a176a3ebdbef8e4fa8adf5a49cc4f4ce55aa7e59267694f294938507ed4f80110d8971050c0c750322a365b3702a41e2fa9b86a3a1a4a518f5db8005a79138b622add11b0d655f287bff5cd556364a040e9b1c79543bd9021a06df4d5dd909f5d478a3eb5ad07c7b8053f156f8e054f6059f8b4de66bb7ef6c51c42e83db6b65e6277053a6768e12340466f11b41590950ec93c3ee93716a46382c2b0d0da07f731ed94d3fc52967314e56ebd8f0607c8ebb75bf8da2d8cb369df65623e74f87e81bbe48da0b4b02e61831b43dc011361292bbb15a29fb1519a636d6c8dd992dac19517551a7a8d50ec7bab1998c9555a16d483816e9a9565a6f144fc81660b173153ba1287ca6906992e77b83d13588b0401a20227b3ad330719bfef9141ac91667bd4efbc3e325e90b61d1e13bcf499e0a476e1306bf939f45107ff2d44e1f1fa55034b4b7b4243997f01a0a85de0ea6d42a69c913d974c672f9547e676b2d2bd93c2fa63028901b5f8e211a97de5e4a41b4690efb703c8a03a78de8c4629b1a558d148a5fee70ca0c6d670c3fb7cf0565287c31e49f059da28e86707f04ac189096790139553ea00d524c2d1f5617f3e97a5d302d83d2a92f16d3f02a0f72f40115513f8d9b9bd917e84b622ccd5ff413897e071dde2b3c2492470cd25e7a41d3c01a48974b40e80360ee8f6e47f5efe822332e00b96e1259d7c5edfc95d1be065dacea8e469dd6256bed9217a251d73011ec5c69921535d2311ef780ec62f2d44ea12ebff0c6644f7275e3d06eb8c6501c301c2ba7e39a811f83642aa275b986b079fe96f8cfa32544a39fb55ed72782f97b1a1ce10e21216776ec328952c0803efabc07ed4112e2b44a1b5f0521ebc7013ac6511187fdf0cf1e28e34ae9dc0c0eb5eb5fc0f5741e3d20bd2f11774def97f66c8b344bcbd096a159b2a309f248992fc8e82328a42760598641a91c792649fe41d4f059f85fdd08ec3b6e81f9a5eae7689754deb82d21872b75295f6bb003880902a05287e3547b92f83a06e465174d5bfe48f1aff0621aaa6489b727360f7ab53ef9f68529284601464894df6239d20fd0b7c9bd293fe5dacf58baa6f5b68f29f4dcfd4c728864b1e10647137855eb1d47ee03a74efb44957e62d58d1ba7b0b7af067c1f656d19913e6853ffb9879efd948d007395cc9719a9e01cf6190cecc0d33bb748d23d92f555fb4db8a54514539ab7267732d41e08a6238912917d15b41f717f5602731e005a4f0b2c1b6392022566def73c54b0b3ff53cec85e632b3934959b087edb07de0d93de0fb1ce0f55d1d369d6dc8bc3e29bbf15679c8f09d2bd6d6a003eebfc2c2cf61524dd714e2d718cb698c8f7775f9a910aa344e5647b349c9c7c79cc652854388ff7bacff399d3209b91b06aefd2bd52515267a9579afede42f27dbfd08e5064b2d5bca5123cc13250c8991ac42a2e54d5a41dc052122d1c748ddd55db749ede6660b8b44195538fa8721643784c60ed209367f36da0e165f6272a5f35fb0e8960dbb5b16ff4299de12fdda6467aa54b99186004618748e2eae3a332792189c3bc14269bb81c6462a5d38b9ccfc12b9c30b591cfb1df75f01bde1e01522f4af7357a5694ae88ad8c4d652843269d8da72cf22c928b9cfba9d373b42fbf506e7efcf7f508a07941157c4a33fbb9e18d08cdfea6a6c6a30baaecb4dd18faa24f8c4c0435530ef52947b6b2f172236a911660478b2d590f5b42067d65ca2e5656239c453788aa6abe62b07cdf3dd3c10cf49bdb1041059d9ff5f1c1d6a8161fe1693312a91e7e8e7c8de6c33a9431a96e8f489869035bc29e2ce52125f925448aa4860ab38e4259a7eb669af22af1629cc7a257e84b876d2740262bc1cfd97b2a16d4eef33eb6f2b647a6b61fa3e4f237591a0f6110ee46d2a06ec35eb4bd750678e090a402bb0767a6974fb2f4c574093f32818de2afa24a9be12994337cd9bd40094a7fc79ae73dd181abcd4ae2bb9c970e6c607b0ddbeedccb25d9066327df9fd9fba10b9fdd8834ba7c496bc54d3c6cccb84a08b8f7a390bbfd7943f1c2793f71ff27881e088b3d641df6486a2fee81536e61f7b084bbad4af3409277fd224126d4782301fb0b8bb710f4b9d3c7f10682e610384b6275ecacf3da443c46049a80c635d816c5e634cd05b86416acca3b21cc1c017c36c0c5677352175f9a0b2a78704555983f69e7e85bb94cabe3245246cb574a2cbb768d024ac7f4620d03a725b56817fe2a59a11d84f76d78c40f454710fd13a23c2cb63d45b846228b0e67f3415cf9cdd48d9972b7da205fbb22</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>chatgpt</category>
      </categories>
      <tags>
        <tag>注册ChatGpt</tag>
      </tags>
  </entry>
  <entry>
    <title>开始接触编译</title>
    <url>/2023/05/05/20230505/</url>
    <content><![CDATA[<p>编译学习</p>
<span id="more"></span>

<h4 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h4><p>编译器是将源程序通过一定的步骤转成目标程序。目标程序可以接收用户的输入，通过内部代码的加工，计算得出结果后输出。</p>
<p>解释器是逐句执行源程序。编译器是整个文件一块编译，因此，编译器比解释器快，但是出错率高；解释器的错误诊断效果好于编译器，但是速度比编译器慢。</p>
<blockquote>
<p>在把用户输入映射成为输出的过程中，由一个编译器产生的机器语言目标程序通常比一个解释器快很多。然而，解释器的错误诊断效果通常比编译器好，因为它逐个语句地执行源程序。——《编译原理》（第二版）</p>
</blockquote>
<h4 id="Java语言的处理"><a href="#Java语言的处理" class="headerlink" title="Java语言的处理"></a>Java语言的处理</h4><p>Java语言在机器内部处理时，是将编译和解释过程结合起来执行的。Java的运行环境是JDK虚拟机。Java源程序通过编译形成<strong>字节码</strong>，字节码再通过虚拟机进行解释和执行。</p>
<p>形成字节码，Java源程序就可以在不同机器上执行，因为字节码可以通过网络在机器之间传播。</p>
<h4 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h4><p>一个源程序可能会被分成多个模块进行存储，放在独立的文件中。有时，<strong>预处理器</strong>独立把源程序合并在一起；同时，预处理器还负责将宏转换为源语言的语句.</p>
<p>经过预处理后的源程序作为输入传递给编译器。编译器可能会把这些编译之后输出一个汇编语言的程序：<strong>因为汇编语言比较容易输出和调试</strong>，然后，汇编语言由<strong>汇编器</strong>处理，并生成<strong>可重定向</strong>的机器代码。</p>
<p>大型程序经常被分成多个部分进行编译，因此，可重定向的机器代码有必要和其他可重定向的目标文件以及库文件连接到一起，形成真正的在机器上运行的代码。而<strong>链接器</strong>能够解决外部内存地址问题。最后，<strong>加载器</strong>把所有可执行目标文件放到内存中执行。</p>
<h4 id="编译器：将源程序映射成语义上等价的目标程序"><a href="#编译器：将源程序映射成语义上等价的目标程序" class="headerlink" title="编译器：将源程序映射成语义上等价的目标程序"></a>编译器：将源程序映射成语义上等价的目标程序</h4><p>这个映射过程可以分为<strong>分析部分</strong>和<strong>综合部分</strong></p>
<p>分析部分：将报错信息（报错信息在符号表中）和代码的中间形式一起发送给综合部分。</p>
<p>综合部分：之后再谈。</p>
<h4 id="一个编译器的各个步骤"><a href="#一个编译器的各个步骤" class="headerlink" title="一个编译器的各个步骤"></a>一个编译器的各个步骤</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符流-&gt;(词法分析器)-&gt;符号流-&gt;(语法分析)-&gt;语法树-&gt;(语义分析)-&gt;语法树-&gt;(中间代码生成器)-&gt;中间表示形式-&gt;(机器无关代码优化器)-&gt;中间表示形式-&gt;(代码生成器)-&gt;目标机器语言-&gt;(机器相关代码优化器)-&gt;目标机器语言</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>以上括号内的内容是编译器各个功能块，无括号内容是输入输出流。</p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>1、读入字符流，组织成有意义的<strong>词素</strong></p>
<p>2、对于每个词素，输出<strong>词法单元（token）</strong>&lt;token-name.attribute-value&gt;</p>
<p>​	例如：a &#x3D;  b + c * 30  可以被词法分析成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;id,<span class="number">1</span>&gt;&lt;=&gt;&lt;id,<span class="number">2</span>&gt;&lt;+&gt;&lt;id,<span class="number">3</span>&gt;&lt;*&gt;&lt;<span class="number">30</span>&gt;</span><br></pre></td></tr></table></figure>

<p>原表达式中的空格会被忽略，变量a,b,c，运算符&#x3D;，+，*以及数字30都是词素。</p>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>语法分析用词法分析生成的各个词法单元的第一个分量来创建树形的中间表示，常用的表示方法是语法树，树中的每一个父节点是运算符，它的左右子节点就是进行该运算的运算分量。</p>
<p>上述例子的树形语法表示如下图：</p>
<p><img src="/2023/05/05/20230505/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90.jpg" alt="语法分析"></p>
<p>END</p>
]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析</title>
    <url>/2023/05/04/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c39d26d1dbfb3c44845aa013d0e2e4fda400a07ac4c8c353a6165c478f0224e6">4630436162ade97ba2718b7d0c4b3b630530b9a27233c00e0d9ee684a42389a87a7fe0fb5b072a3a0b66a0d479a8f84c825b7f2be28ddd2a739953f8655cb7325b202e3a846c39086bc97155c25ef4d71de263dfc3d27ea57fa2ee7903fd8f9723d4b0fd84e89d94964c23f53b75e658d3bded1cea32a368aebd9e64f377a0dbce94d21bf66c836c1a0db9e5016a832dee9b201d9becf5478b44e277193093e599692e1a4a19bc2ff0425c27360afd7305d52281846873a997608e879ef61f9d8096b98272ee423f1a8a3bd971e47ac395a4ba6b6c8a11e7570fd410996c519414fff9e27f0d8e5773f10f948849a81b53f6c2fa1260196f595cc0ea8eb7dcd41f17535cdd1312fda08293e8fd12535b25d461abec63dac0ca794506775eb9832fae74998e0b564d5032f8195f31233176d8b2071bb7dea1eaf61aaef989e14744b7d22ab62bebeec812db24edd00ff629dbe145651a4af91876960b847fd9642b97d30d0ff0abce772d2fa39ed9a7ee99693b0b0bdcd80cef59e8abc129eeb17e284d6a0014723d7c39b9ff21118270b193bb7d25d9a1e0e0065b5c15446df43ffb9b01b51c4aebcfa3bdd4cb03bc781b372d28570383e98a4749014c86534aa1751326aa904250d9562a46105201b4dc36d013f5fa1859c71d914c1cad81b88df87aba26a87391df2a2081331683a73d0b1000a2e19c908d05106cc53f0164a44fbd92a643983b540943f0334a68c8f0394400afdba85dd66d47218de324275abb90b380392676aa203e80f4da7e332e97a10a7ac127375dabbc16706f5411a28e259aeb9e324f30fbc6d8ad411f3b25cfa840e009c21b7b188cce9fda5cd263d0afd0c7fba2bc1c723144191253aa2a577fb12fdf271eeb13e955952586b1187d2e0ea37d7719a7cddd50a0b81b2fd17bdc72feb7b457282d8d2f8d179fa6af2e9cc2181fb765be052b64af86b8928179f57f5a0a9f64327ed33ab46aab166420b06409906275283de357bb18bde0e77c408e58c5e27f345f07bf129badf7737771f2d62cba90d4fc6ae7de7ae2c2b7871514a4aaaf341f60321ef02e5c071c94cc0772590e0505b0c5e64fe45e860219a1a44c1f697bab1d988388867ba1ec1e72a07d67732b6d23ca92d73b718df6075a7a619dfac19b2430fc9b285774230f7cc5496257b5c794272e637b2aadfd5674f5cf372f3bdb6eb2d164013bdb5f396544aed12f69f50399bebff8e1d10b835587aee84b702ff6d7f5bea79aabf6dffa274a675d13d241f773143da319ebd17125b9fa711f2dc10362f669c660b8d210cbc02d372fc1c70b0d2ed30788b75bd9d42eb9ebf8dd20334eceab35e9830d4b915fc408ae192a1d96e5ebef239126194243aa234cfa5e2484bc832eef202f1ba86e023913eca2917ed134bc03fd0754298cf606f0553508b99e10a5a9da9b98daa5a666d4bf3876ecb458dd9a712bc07b07853b4df24b725a24521d334620321a34acfe3167d4fcab140a81e20b5c2411423ce234cd3c05c4f53e01e5e16c860679483154bae8bb7a073b32707cd839ca017ad8ee2c89abc5acc3f9f6be6034fa6bef0a0ba491af7f89887787929e2733cb0e56c5a43ce78cc3834af7ac1072078bc4fb3e50e8a376910a5e8364cef72d493f259e606be053301508c28a7c4b9c3bdb4fdea509ae4f0a80b78f33af9dcd7213cd63426a546f3909f24c073098180407d669235c1726b122332aea11e186c112ea72b573aeee8d0560fc989312f83c869fdcfd802980172d5a782926a7da64fac2fd678477de494e8b6f882bbb77ffbeeaae597371cc6d3d57e4a5a9a26e81bd3f16cb6e4dbed11073424e02e7e1268a65f35bfdefb6d199bdc16c8ca98e908259bbff3b4f138901fe6bb086b1a71ce6c03b4cbadae636c85132f54a2d79da9be3d322dede1d19a94e30d725e813e97439759dae389356cec21de5a13e05fea75fc9392d8582883ac49839f403ffcce949a81f96474250694dd8dae807388de01304735a2f968d735e704d04062df4c3076e5e6d30dfef4ee6f1e30a9c80407b16942826f61987d40c4f53f74b5e8de565ca280af2d4c92b57f310ab752fd1f665067e5d4c4e8bc23cce4b169177c3d4ef1f111bc7b88cec5da1fb2e4bf2a244679a28d1f92c6bd00c60e0d854f646fa697fbbfd3089026893ad5c92d79b8f9826d99eb87c67c6cb67b162ed6b6cfba8b4ba5cf9851446d53ca9457bac9ce2827c0be2ee9225112e50d88557426cf5842fa2d4cba7e777f255d0cce17c3d0cf2013b15efe6b01dd3d00321a75418fc6bec2dd63b283c3bd242a858e0ffd3a2558ae41273007f50faa8ccc744be525dfc94abab026f8dba0ef349e1583b52ec6aece3d0290693dadbaee814161e6974a8d1e3a6b3f2c04d7932bc0dae06fd4edf8352ea22cce706e4d8d53a6d176908e3b9c4cf4ad8e8215e8bb61f943b02a14d3dda835ead1843d067a817be6f8c0aba9d36f2cf2e1532004ecc307207bd25291b0cf3ffb816c07db8f6f8a9409f1b739e938bc440a428f74d3c1c1d8eee15e17209b7f3441616c14a1483506e25f7162d08fd0e51c656012acdd78fe7301eff5b26ee2bc609f322aff86095960912050cf6492b121d80ef89cee75b6711cd1d3a3f89baecaf3ed5c4ca01e4e2aa71ea88091ab51b18abf0c7f2f64bf63daed3a769e37e1a8ca174c31b0cd9ac13c6e6ceafa7ed1e245a41ad6dcaba5a854c585020eaf5027cf47777c609711a539c96a9ba90b316a661a8e62e9a147f3e6f43ec7d80febe9b32daa00fe9a4ac4d3de858897d1bb3be1e792bcde2f4a2059a97ab5976facbceda92188410921ec1558b8da4a3d1653381959e6bc4d680d19f5c050ecf79875b46c88bf3cf780575696fffd393d9f03a68fcb0d81e6fbd97677835c85fccda9feac2779c9a42e53dc8de9d68344b6bce8de0d52515f48ae53ee4d5e8e33bc9f57eb1b9e7c61261c691d4f169c63f15714a37b861e09bd94d0bbf700491f219f31b8e2091d6dc2f855317dfef4894616c7d2d1141fccb9f8508873e953e3637afebbd19ec409bf2283be99f3ae0a8dc3cc4f4957df72ffff6df1ae66c4bb5084419b6f6088e9842abf3684828a635be0a13bdd07d0c4ac7fcc80f1617d1b5f5e6abab6efd468c01d8e609019eed4dbad35a0ed4b37bc0312cf74e732ef08b154a28fee81fafebe74b04ce1b2df3f942f537bbda237b0168a3d8918f6f7f506d2b9c9b680d31d85cd466f876b66ba2f1409ca7ecd44737652bc8502899188483a44305e665c5d75339e8ef767c2af235c4270677cb28a8602eaf869038fc9e7f32a4a2f268698125a9ebbf222416d2ba976130fb5c5f224ca193794563d98b7c65d19650f8ca55aa920a938c3904ef1b6bf6ba65473e57b4188791540bc2d30cdc8d3c28f676a6318e64246d8986584d9394393a8c662ecb17c32279241a56f433e92cf13694aea2336c4786ea6ed35243ce85b1c7f4efce3c62c6a793642357fddd8a1c5e88d4f1d8d1752230177f8e83c98289a7cd1e485fd794c58a9e1370f5cd10440a7adc9df99ffd78bbfa2e988760e371fd9fb60baf7686189a5833a051bcfdeda320a2eb72b90de5d007e4c150e8383674fb546fe7bda7a131b47cacf3f067cfba67600108a1015f277570c84cbc430389e7f40cbdf98150cc75ee91718fc1423b02dd32b5df1b5bbac52bdc6c379fbf12866d838de39bcfac1ef9d4a26574c04b8434e1b9e48b0a2bd3b4f3dcd697f335f995c85cb870230ab718b7d2fbe4f632780b0605a1c3a6375d567713a3afca8db040291c3eaaa5177fdbeca85fb11f07c765d6d9bc8ebea5f40390d8b41d183deda4cc518dbd7c5ccdc2c195a11ac58a8b925a28d74e422ceef83d1ee9ab9b1e90faac456aa6082ed284076739185b1ff10ab51bf47533c2a90b9c9a59da1ba06772e53bdf318e1c0e9f184ddf3e22f75eb58d8a1030bdf913d8c325440e965c0e406391942ad811fe96cc5d636133eb311509b810e0cc504f5ae1b4e308f5db20d7d71dc30508b8375a0c4e9a6fc37d19f40d42aba078ba56f0becebb799dde23f19d223988a6ba5c771a79a11e31f21004f26737f37d6c336caaf9c21f29cf831a104c6fa55c63358bbe51329af635eba185b2f68d9b41b31f1eee8347a859f012677fa98dc967615ac7f9fee2c4261fdbaf5ad237afc0cdc1fe3e3d1b3086ed79a24545b041054d5d48735f27766f5090cad27ed5f76bd08d5402a9a2f56421590170c0e7984ea918ad1e59fddaecedafd607d0c61908ac14666fbdd96d8c3fd6b7b35bef976628a958ec2c5ebbea9125ac2691d67452ce65a9a0ead03cdeb44f6ad5fcc899f50a7f88e177b4c37c31f950bfeca7704fe3527032885bf2ae3b3bfba75726a2560790794eef1e7072b0db46ec820bf75deb46aef4f617d889afc69ec39e7b517f8acb9f1aa35d9f3dabc3ce55001b9becd80c20eafb6aa550a7509ac9292b5aa1d67090ae637866e4a2173fddc3a50430189db16a7eda93184b02195433d9009e1e81b91582c2785c9dcd0ba2a7a3b142fae569de1c63ddbfd321805e4f70be4585bdbf299d0636d40f07d580db679500540a6a427f1f311003ecb0642c4ba58f4360a41660338f2879196caea63500205e150b9d987db074e3a641236e387ea549a970515b3fd86425dec8bb1aebf4880325bf0eb7326fb25a5f657191521ea2b785ef1bd7772001ae5af24e2e513bba2fe7a0248126224df2a6dcee8b825616114df6da4006b6d6fad6d4440587239706ab04059670dc8d1e185995cf3791e8024187127ff08e2a1c20bc911d645a0842799becdf5b807e5b21347da32ea69d940d95f9ac74bb2849605ee64ee35b4fafd06e34213f7ed1f34ca9e820808f1ea5e90594eccac642db5dcccd84e1ba7b6550dfb0ef0e8252071d6d684bdef582c3033f475e5468029697ace4df7bc0f97e37c083a08dc1a30c157b0291a25155d26aedbfe2d4776aeea7c1737200301506c3771022f7f950251bcbe45f7729532805b45c3244fe3d13625c0588286edbc74b966341daefe0244a07e8789e015e2a8978b31301c6bb77de0cf26a28ca6e5cda82711d70165814ebe0e0c36952c7161b4ba0665d2c915ea11fd03e6db4ce82c9d95e9280d914ca1387d23f6e189fe64d90b0eaf39212dffe3745c0e883272af9d265d4078530ce30869e2253ae657c36347aa2c3ed19348340e3eca082a09a3f242d4a9f014d64e2d68f203365514e8f540dbe4ea126903525f1bd5a5723bbd9ea86c24ff2687bffc56a072240394c32a8749a6d1f534710bfb983a713a3b9de374706c7024707ef4576c0aec2c3e7b5e0fb83af2f8ad2753b9da292defd0423bb94d41f8dfa52574b67adf4bf022310dcdfaf0f5cc6d0fb85c3398c1f7b04513bff39fc2e069255e3a999d0eca633541ee846684d2ca96f3d966aef9f4835eaf6f115b14db30ffbd2dcfa0ded9d6a4db340cb8921be316162c3e249703f2e889684770e74e793a51e31202103c1c0762d3d5dc547c2f4455f33051390f31d4281880d2d22dbfa008dd1bfeda5321588335e42cbdf3c713fd2db9d7b814f2a30321e30f5c422abae379a5ee62882c7047b43e2f41c0ba886a6dbf452974db49ed773d9e0558660ff5774bf785b9c1951b18af228882b305f918403a5465970acbc4c0e774d1ce828d9a40968a2874ae92b7c946d95508e4c4fd8aba23389ac8c5c40d3b911296b7adf0ea52364da6121ba3009135dc928da8dfad02b40c19a21741d1aaac906c4298dc239f8462553d48d8e262b313238e2a5433413fe558ada3b255aef74bf38eb344f20fd1a5aede44f63cdcf0d415eff9db8ec2dce59e6243703e53eafd0c6356e5a0a15c94b096e5917a110bb2268f5f963b586a79589f8e6539bdefcba1807f7e5fe83f4f5ca4fa2b90469cdfba43e326eca256747e0109af2cef2beab441c86d96af12be69eb432bd8ecdf2ca0708b7ffea6efa768649a52dec482331c21aac501844fe2721d141b287f1c1b62426bfec7a5b73aa14d8980d6410c87b609a8518ea61b6f833a25e01f73fa1a1a59427de9a21f6442877195be566fbd8c81737a80b5cb25861c75d95404f7eadad0d22f3a27892e365566cd58c83ec17f8e6442ca444954a4e09551e7ef312d8566a418ed81ed1e443afa3ed75de55535af196327b44d3c29560c4f92ceb2f87b46b5d9491a78f2c9683b66b5ee76653b6d354981e33eda98734c0ff6fd6828cefce004fb61c0f8ae7d3ffe0d7a2b88c0a8cf1ed4b2d1474f04c4eb87403c208e10b391eb49d81cddc60ea55a8c3f959a00581bf10e2658409c7cdeaff2e00d3eaa7270b97021ccae21254784c65d60f9216e7ae64f4e68094143beb73401959359170e206c148ff92828792cc2ab563b1ecd2f278224077d496f172de49a0abd4c653929421d6b28b9c09529d1983680b2a4ebe6a6d6eb619b6811e8250d3fd6f4c8ca9b63bbc869ed4bbe34dbed8d1929e1406e0aa702052838067f37a1add9a5b40b358cdd2a12ebaf658e1b30a0daea5dbef019157550848e5e6c5ce3f6b392559bec0dde43ef45005777673ba91c2ed47e177cbff654df69d049a3316895df8573f6bef071d5bb140dddb3d6a88524ec357716cf5ce39580060442e7052e60b15468b46b6f213e1ba749d080e02ec495562d392e8c450f50281bf2ae6ce41872454d6abdefcaa68eac11b98b6bbcf05af6189398c23054ad70066c47ab8dec368e09956af5eb795787d94429468158b4299cca84d83cafb1f694e00befb7682f4d62186009035a6f074bfb68dea5a5be397e04f191446d99668011ed44d5577c8c73ae096b928fb40bca42673c3cb6211e70901b33b4fd73e1ad9c2c192298e0bc12b8d815a9225376727fba21d1887db4762e8871f3b0a8fc5d27d78af312456331be0108381031e60787f17561801480a039fd2fe60206d1e475ac7e3c4b21f2933f994728692c6dddf1512636bbb01bc67cec0b911ef378b7b63e952321bad14b54fea903ce028cf4797719d90a8853fe21c88fae2e2d0a872ee27358262aa880c1ec45d862814b051707d47d057e277087178f4a1b72aa475d5e1b16712345ec307eda2e9a4bf513036da308ed9c821a8fc2adb99273dcbb961b74ac6cdc3910b21c3edd41a19833c25f682b8f220cd14579e986a01ab20e32ce3f54db80053494f4bc99bef0aa594ed8a518496a318079d4dc73ee4c4a5c18c3f3c33ee86717dcc675434cd7d3e8bb075780c72516cf9985b7dc2a5ffce4f4dd581be33adafbae1a199133f6140d59f75307f102f7c0d111dd37851de3522fd35708dda64a025e7706aee28ec5260ded7e81401066a372a526e37215991d9a0911af1c419b6eb887eb6ff5ce4a4bf1361bddd37397af0e2ad9097db047cfe606471e3e91f26b6c365fcc9cc6d70704377f4276f534d84a1903cdfbdbd7b1cb35913547d9d6f897b5a0832bb2ccf804a6fc5fda2e9e8d44fd2ed1cb936a2256afa07c462da88077c7e5da8ee3dfd3256216b432d041c11f420ca40703fc3ac52f117a73dce46bee15da1cc15ff57e25711140e2de9db013b4419e025a06e3785691f13006378751c618198f2f282ccda04f55258542e8b633a4f3f5c342a8415286cbaa370d98eccc8081b5e6015c43f4124fa200b451bab48c57911ae6fc452df30d93ad23ca662dc47d5880acaa0c8692366b2df287510859500e73d68208961b49aee0bd63f12491eae4f6f71080d00eb838ac8333e88025ea7805aff8f959a2b731df3d14c993f318fbbb051f5cf57bb517f373428bb29502ddc5690d09b6edf6b032e575600c420e3cb741303878f7be2edd46886def92ea919d3a3bc357f144539cbfb1a8134cb9ff63ca3c2988261e5a2076527013ddb0a65d216a96027f1d173c71d2ef7eb6780decc0d0c58d4c8bdf97151f10f69913a0f3c0471a34b4159026fb735d10a94089107b5a2409c1ee038a1daf6b82c1620bb89ec69ac72dc45b39ed9528dca47456601d677fbf4850965857683b34dbf0d999b9e52c5089687dedcecb75ba64dc2130d892b6dde4cdb8992117947b0c6f75f80d5191c36b583e7aa6cbd75877d81ea3ea0b2194f5252a63115b176dc9d8d1de12d2cc1c2fd0e8fb5f6b7cb14efa5e18912ce59e6a19f6bca92cf093e6b95612478ad6d1be5ad28ad3ff7a7dcd4fd10911ea3ce2fd789e4a3a9bb309a1daaa6727ea185bd66329cbd76882936faa134e721da0a7e19c77c7ff36fc7b9dc63e63fb947a3f29571b71b7cef60ba240fff3e8cbb1ce9f1b054111a83a65ef12bbd5e1a9495646c1bd2698f1e185fa2a035d54c933ab8d1cc6a37fa63b8c8ea262370bbea035e919147a5eb3faeef8c6d3f5a436a487b926809a6cbebb714a0c7281bb06bb487ad17a58e25acff392f1e5dda2e566da9b7d817ce6795908f08c7fee022571f921dcc14438025d84729d557bcd67d23dfb1a3cba1181d41205f0ff4f0f177d61a389821d9a4f47592cbc8528e281db8dfcff7a33d203f45dc40dcb2a837ebff753bc5c105de7aa41f45f17849b836ab8ffe5f3062d2b84c35c3e1fa030bba580fd888c08a26dbb7b9fe44bc13b494a4b69b81aca2aa25de4d48da3ec9aec952ff36ec8f5e29d978b8b18f2cfdb774d0b2361c482327afb290d0e451892df44c58e1a9384d006cf883fc3525a5b2b680f81c5efbb3b2f95390c1e455cc3dbc5b1e7812a1248d562930895eb8c0110d1cd6e63723433377595fef0d7171022b3ee975488ca38a3ad6402ce3560f56bb3069421a8155f770d08c8524d8c050c6d6523115b11ae3d9007ec212a88cbfcb5d7690910d0212f99b1e7825f93bedfdacbbd59206b14fa911b6dd3a428a9a748efa7e75753c9000ba234b8306391da6625442e3d0a21558c27e7d3e20d50d749cf98431af08a64281e2b32dff91af743dd8bf44886be509339916d69f4a28202588ef605cf7b3cc51eac1c5f77ada5fc0d75e6083197b097f743d4a07b18c7a1923d48a5be95e1dc60b68271b647406c39c81e3bb0d7fedc971fbdd1af843def5ae49504088f2527427774a8bbbc430ac97f5c80528f2a9dd0ee76151247e843c5c05afd0fcfe60223f9c18e721d8464001c86a08ef0107f593be46f6b5df629d6cccec78cf4a7d50dfef3df72c17c08ac5caaaf0ce5231dc311c4b00a6cbddc0e6cfcbab40b9bd7ac9b2fcf5a5ab90c6254a00bb1f95bb57a8b7822abc9ccec569c5ee4dac1ac0f3685a6bc849ebffaf26c386e44a401e8db3e389d9087683466400ef0ca4a224e7bad2ccd6f0b050d85c36d82038eb0ed12128b949e0c7e8f736be20183f333a82aaef0d7166cbad4ca02dcdee4457a509bb2d55d6f3dc591dba52a322f6859546a1bdb82eb140b68efc446c9b35990d0f9f746842b47a2feb83f56dd8511739a627d52bc92bbd338aa2ccd6f7c6b596866e12679e441ecf4ea8c61f669c059e025d3ea695907ec86fd4f071259eb560e43f82a3d47fbff777c495e46f8d508995037d1087c8474aa9f004e687be17fa3dca4f36770d2faf05693511a1c2a8848e267d100cd6f08b54fa7795e0e0510a2545f272aaaa77361bc4545c6d05f8e82fb5595e02ba4f7f79025aa86df438806e85e095b869424e57fb680765f99b7f9221b880e41a6ee01e5f05607e204901f943b98d2d966e0b57f28cfdd8aa609ef6670f31e65f94ced38d8d8c1be0dd701c96b7862e05065a577bfac60bd9a1dba13324eae37adf605de83efe3bf43486f0cac117f0f14690718a0c4780618a3c39e24bee98337125d69b3915812167730a18064ea138c8dd35a43673cf8af7cc90ca5c1fc92279dd65b38cbfe3ef7021b38241e3a43cd6b1235b9109bf3603098fa542875042204702ca78046e23fb8f74270e5293582d5ad767a08ff1a0a270fa91f09fee1f4317a48f13f20306634b69e648f7d2557ccddf9f30a42ebf3dd18462e408828aed2d2333c4a86d4e3b322cc828dcc875d85d5a22702f1582116ae0b91d2f2aec9b94f47e575d7aa45cdd881f7ed588d3083531ca1d476659dedcfa084114dd2dbb221666d6c63fd710413738de678a1010058b00b6fce82e3eb6623ce2d62967a55dfcbe664a7069470e826a0cd0e6a24e7ead5fc2b57b3be3d0556423fae74aa9a4ac4fe86e35aa45229bd0f955cb5ada9711f251d009dc83d6e91b56ca23609b415fa6f51916ef25278050938bee74da18a8c76c6507bfc479688406e2f9ebdac536765b0b8339abf6e93c57ee7acaed968b519cdca35ce8525eabe771f93ce9fc7cadda03def47f2c2b4ca7c6cb80cdea2a28e70ee92d3de3b7aa67c24a6694f8fbd4240127f574c0b0e5f91e82f0271ae561956f30fe49427140fe86f9c4c8e93a817c90f1ea747436520e1218dc441787334333ecb4f06b66db33b659d7da48955bc0f136750c778fba4e2030035c226f3feca0046e073ff2e80add973b9d3cdb873dbc7bac90f99ce4b924a79819b8ed757af18af908770113ee7e41654c428840f08fd5fb14dac86aaebfce084871b2f576f66be56bd7d2233d4125529a5b85b5e6cb217d7352dd37da1b7345ad6a4663a496541500e23fc62d66c49378e0bfd99f9243f0b470454f31021842ab5e83608adc69572145dbd889460b2aeb7f9266c1e9ff26d1d8cda0c427b0bbce51e26cfdf26b06e64e60c5d68cbc06374dcde1894df6a9c85b42aec2969768fc83da84f3daa6d88661930ac14d65f5f0988ba830315303a2aa941e6f5aa98831f2317ff5faa6b871cad1e5341d0155db5abebbe6e31e18e3d1ec3eeffef30e74b0003ce31fdf59fdb9cd27387dab1b107cf286390e746a4473191cd39d29a95a46dd6d7c585089676430d05d6eb8ffbd12377941befe7199520a6ae2d79851ea8345689b3431cb476f13fc7ac324f129c5324aad07af68fea5c76cde30228920d9d0017770c015ee1ab24976faf1fd264203e188df97e5922e82c0c50673bbb28d0cc2881f1ee78ead38018896abfdf111a3f3b17be29b4d90901b0e787865634ce545b1d64ebbb84516e5d2636dde080c30a58425d45d72d3812c391b28b6112e8dc033f53247301f1bc4174ba47ea43dbbfb5369995ec3c35fdba8c0035033f47f64c2d6a6b9b39ca644e68ef3dc9aea5653885adc8735ab675ca9e130b9ae6abc5a024d609b2be5d8cda4a8bd5d8c3cd4b96d448d1df4137cb47179cfa12fb3daf2301a6094be6cd2e72c68d8cac078736b49d4bc2e7f8f00073eb83ad6c99d5ed112b181de1d830deac2c48b699c69fe4b7419c61f8537c24f4a2d6734622c96054fb203ef197bc78efe7c6dbd6584ab4cdbd34412fb4eac93193628bb053d52bef98071991925d87cc8149be71006aa7d9d6bb4d5b72be7c26422878a9eebb41264127a1e2825de7854905ba1497c6915b9847ffa569308baeb940cb64af88b9de8d5d8f8283b78987f50700866217b674030165c7c724e1261efcadf0166247898a72f80ff79cf2f3d4667fccbfa5f682b7c12243d318ec2c7341dacfe4ebf5bc54b62b25c4419d19e82c0e5acbf6db6fe6abb58259017ef8f65e8425c463bb6934396136a1da03e284639c31335f9ff951c0440e9da3628234b30bd06f2fd2b390a8d00e9e94ca87900187830be0da4734b1e3083a5e83a242ffc5f2a263d90c3c89fdd9c9bb80faf1bbd0b19351f5f1d5bc9410c3f501c39c2ef048b41d37bfa723e503b47184bc074f7f3700ece5f27849ef3106c5557ef8806a4e7c953a26d6bbbb83eab448142977a6ffad516b2f962fa4d11168c6b1373c39f9b453eeb1f7e6ac10d5ade5d4209a54e7da30a526534da5ad8497b883ae82e49c303e6a77133994feee68d8ca2276e197e64aa6730198c05e45a6259e6e8bb768a6fc2b92c352315eb1815b709af1b591f35f31819ccddbb0675ca089dd46a18f56c18567d2f1afa22c08378968eae417da3209110dc7aa40cf23972dd73f9bcc2b15834c607daaa2b54c2fc0dc1ab2cb44abfe91b5d38c5e32c65b6652c9e9ec47284647febe0bb418b1fc0fa224bd2af0abe6c07b6bd15dfe8190933f8e2d319d3eee98757688e25bc4969ad86c795f1f7c22c1dce5cc0244c4039b382abaa5878d50daa0df37c3b24416c7247b619cdbbd52fe4e80fd6f42fb3983c70ed8d2b81c63db6c1d6cdd5a3f0f90b67bb25ffb751633753e953fe5212a66adc299c5dfc03b01afe112fbf6206d08a4d2e033bc06abe8d38897acd69a86773241a97723b8b296948830fe600ebf324955d9d68363a2d86f2694a5d0d946b3befcd232c392a46abbfccd9179af43e02c1064fcac9ea5d60945cfb232fcb693d8c2453e58c850bc13ee745c3360f2259bbff4f14240ea60128e062f32b0db89ac55ebe64f9a6de9cb7bebae0a2db7e801ff169e5167997349bafbae859d553edbe9faffda63bac8edfe26fadd6fc569dd9a7cad6ea65652944eb5c1ba6ddde8429db98d95b27d3b3fbfb7f16a87af2a26c4bde29af7d3d59e0facd2c9f1a6e6fe5339f0dbd47ed6a06be3e80c71f31fa4b3862457404b738d2eaf3d24e692a6805445982af4a2e8e214a3ef10949932ff8f4746cdc091f951266c42d56e11ad1e1b8b440cb92df6fa5e7cdcae506017bb1ab14a0c8b56b9727a1464d5e1d824c5d49ad8a1ac630c3960c7822139d910b44304920cfd71e2947f904a4e332374239d153ca7b7f5bdfdc1d2924511c487ae043bc2c60e04a900b2cae48b21b1f74799adef6c17fb059d75c6b9cc43cce17800a54dc80244fe9ae3a3e11ed96b302cb84738261a7b30147600bcc1b858d51a4e7c07b4705e0774c2c34fbbc8b8d28dd7d750d1acf71e9a97c80556f321fcc277745ab042e61b83e44b7ebc099ac7ebf95312b94ab0b635e6dfcc7606b0a9308b8bae00fe112361ffc85cbb73b38c81337aca8a6653e3c8cdb28ef76d6834fe5f5ff542028e4d8100df514b13cf1220eeef6f5a8ebe40f6b20bbb53ed528aafe331fbde189756456f9e1970f85ebee5e3d69ea9bf331dc2a28f3a8eb5eafbaeae04709b44d7957c4785cfb7ce83b98600f6a7ef00389adc05e5f526456f060813fdb34d83df5994a4b924f5e2d1eb31bf105f6f76a21cd33643144ca4f1b6be915121946bdb2668640cd84702ec1c933598efba047d4a79df108fbe0c02e24fa13677502865c098aee71410f1c8d5802e1f6411fcfb01d6153866fc1757fe38d01f0825517acfba4cc0e9efac64ab0cb31de02ef097dd49300d4ee5c5723e72429075893fb081ffaa02c1015c72cd3a67d19b36170bfbcd6e81eb519633c141fd505d3e52565e76bb1e15fb928c5435fd537ba65094636be7b4a3dd0b3aa0735f36e2f9fc2cc00767874bd3fae1ec0fa03f689439fd723a760351b3171359dcb43e6b29caa9fe51a86831f3e27a88fd42a589e3bd08dff3dd71650cd917151c32ba688cbdc9ede62c7f4623acf0344ffe12fad930200270f5cffdc07e62dbcca432db6cfa0d7c41b9cc0d14a4292d8534d753c11b5e5d804df4c151e00696e949c52c12ef46b4dd9da316ed32df49df350a01037bc7a8eda9491f3e97ba4d4ab493b19c12b0cd79a98ccf6d1240fe77573ae70cbc87929cc2ede0527da4fa793c91d2124c6b9b7d3711d67033a808e7315aa040c0497c4acac1ff7eba2b7ca82505c504e30ac94c9bb3ad11d64839035485d2ccc0fd4371da803aae9a41bc105db701f09eda9ee5fa67b1e0c3c319798f62b430502b2fb04b2342c8f22fc4e3679637edff90de007fedd827cad5a015c5daa11a3aaa83edf37c3d96aa23a2fb21cb9eb5f508b2bb372233bb3da42bae4c9aa85e12120d429b3180ddccf269c64e7df4e57b7b782f3d855fde541f444748a3acf1d5169c2d549966f3390489706536ef7b833174d99627cc85ee0b174c15c6e75e8926b4ea3fc19ef5faaaaf12f1f653078983d0107c5ca9b0f0c1b2b80f9fd648f90380253008572b423e8494969a7caa1031a61f8f1649601ecbdc8bd17870f2e2bd268ea26537a66e452e7d192b39a98e53f9777f4402712553add9d3c5efd3b0df683646d54bc12a4a65096664fa15ee7c83b034f0ba957573d0e832d117cb7ad39cfef82c9e2e5c14f724f127033667faa091384d5d96fae55f583c8b890c721788e2eec2763ea2ee80208b986439452aa022743686de15ae4c25dae6199eb233ebd59deeb5bb8b0c0a0b7ecbbcfff54fc0bd82081ca114060d35ef38f5f40f322fdbee5b16e71809d3ee42fe62ef0ccbff70f6238f07e215abef8b143b388a210ad11313715fb5f41964f695bf75c7c303ffa802955b1d197ee797ef469c3d4af8ed52f5cb8b5734c5e40d7bf1231ce9f64c170c1f5a7650e82e23b34aa507865af559f622cca63bd85c96c3d21f1776ea0142c83be36465f46a95f7fb68a976a5c7896d016e536b0471c32d6a32747c28fe99006075152dc56e6392a011bd1c8d8ddc976b3527ddb64eefa21c821f1b104c0102ca31f3607788db4af0109f685d9f46e204c8778f5d2b843ec505f0b568ce5b62824074ab88acad9adb1083dfd78485e4bca5b0626c459597e147cbd2977a537268522d405618af53e6c45cf3e061fa1334b8b804eb66ad8c21eeb469475da7d02db0a4212713c32726113f4c873492ee3230bde63686a13c657817f43ae6114ad65e3fc0213dbe682ce8bba841360749216d4616ef792e801fa1d06a2a6711f8d3fcf373051e23a8b9562f2ab2b489f558b2d9a8787b005d0ec26b37a6f6f4a25b3b7a71b887d332d466455364a6f5e3c5fa8b38a3915f8caefe212505e32670144715b156e7b39ac4ff2fd75e75a11a4123897107f556bd806a2e3b2edc6c4ff41be187a29f98eed1d859f9c75edebaf8d6b4fec05cd1454f9b3ee643b7f87dd72208214117ed2063ebf3f65e3e8850af39bb8cc74387c8ddab5cbc2fe7713cb5cd32e71d7216b52ac99ba45dcf5d0bdf59bb32713aed23fe18c3477eff64803ac113768b8cda314493e5860bf7f0cbde869c325d111b572238381c7c0db5347b6e50b9fe9e8170f3893de596d427d28d7d67a0bdfcbccd81c41f3bb1305c7b2d401bdfc68999981561801f7f94de7e6f8219d0d5b10a8d586af90c0991d6ee26635c50b5c279290d6ccbc2d68c7ac7a1ea59c7e21db59c61d435bb339c84b72263af7f99c1f93a887a361e10e26e4edcf053db093075b2d15ae67bfbf5a0fda27545f78065ec65edddde203470f5f44f9916a1e6d34717fd8a57a30fe8927852bce126a18d06df96edd0ca2604d31b3a890d0b61dd799eb29e1083aeaf53ed417af2d37d9b5f11490455bef2525d80bde7f50b2bcec7aa28f4e844973a0aeb25eba2809096da7920c34cc50a71f9aceeb1ab011469c419c9c40217d0e795d76320aa7647e7f1ca1ecfaaff46818035a0c91aa9f156948e0e7b4cd0980cdf2c13c163cfa8c1bf0db0973349b02c7354f2319b23395ec8ff4b84c464c10b8aa1d0e5cbcee593db1d8d93b62fe71c30bd02b7cf18d17e61c4809f9761d755bd81df26bb0496db2a45badf5a17d11ab19965118803616b10cff96b6780ae807edff61270d349e36fa3dd0c0662da9d1ea7a7b7a07f1e51e9459b717a97af8822f2683f07c40652168482b2b59426229b402807279feb89f727926be83edd3387445a9ed5cb3d8a428eedc7891583b2d73f7931dac90be46b463aa92c92cc00383e5f4de9a3e824f06163f66ac4e4e8758dd24401ef8e32f1f6584293d3c789d0bda14e9eb3910bc27221a5fdc44ac000dc77174b27edd02a9168d5dc194c4a3e6f80ebd0a01ae97e48241f216b99997fc007ad6a2547da7b3ecf442cb610fa55b7773bffc026dc5dd0d3b12a9d02e5e1cbc3fa5c7e89dbb0727f5a771270e1bf36eaebb2cbabe1f2e8f37377cbdb8c98c8cf09dbdf98450c02950124aeba64dff0e0ac80810f7cb1e8cc9c4240bfa0f3f233cbc80525664bde0ac6791bdb95c80d4162bf22ff3fa3f3b9d6cf636cb47e61740e3368ef9bf76407455e9b17ce6e3d67b2753f55e8ddfd3869f3ed9f1b19cafe199249c955ad62cace145a435588af3fcf003f4f01a5e8bb1c5ab8f04a3b0e178c18d87589053541f371142595dde89d4c1621cbe58409e91e3be49d74d0307459041dea58153e682ce6853348e5be13f46cf95f24b2b37f170f06fbb0a65cfe3c04f10e3e98cd25cddc3e0a9ae0a42c91ef143b8bcbd94f75f57aa4ef767a755297ea9c3ae06666f13a963846f16e24147a12a2c16bb4d07ae94eadc4f1e02ab6af5eac3893ae220ee0be742875c1f37d8472eeb3cfd7bd30e0b4a68b98364aa234757c091992a7c0d6ab4edf9b5622f587fd2dbdc91f4f76d080dd5e4313b6d4872c77b39a0171bc260a7137137e155e205d5c75d65fefcfcc27c85927637cbb140dcd108b21fc40660abaf530b5ef172b691f550a0929e74373aae65dfc0681f49ccd257d06a735c0e5d92a9b1b22c364c7c2f29f9b20f83417e55f59350be595042a81220a5c5ef559eb7dda7d5d427c32766b7bb6f926ba5e227be189c5e5a49840f3bf896a31c1b67041e50fd6a995ef0fae7e5e847fd7c99765b8a125714472f78707a35d6d260cf053454ecf0aa84519ec110c190c2de1507c99da704f1fb058f948d0c52cd62ed3c846d8ebd47263a383a511e7c852f46f13385c02cedab3be50750ccaf9357fdc484f6a4cb6fdbc5f6fb9a3446245f80f7cc5295d1c2221b32bb0c24dd6a7758a522c64dc767a9d2a906ffcc727aec69e78f81749f7b88f14fa3c824d063bcb27ad7f64c24c226a871adf0125b70eae52a5e002fb2a93cdf0e4075ecf1ab5e830d009f430336832683a8bc2c92a2dfa813c9ccaac2853d4191071bd298d5f06a54e101c7eccd66ef3dbc6cceb817853e79a072456fceccd088a5dc6b6bc91bfda09f8e87a1aacf69a0babec116763206ca8ae44afe6612741275d85e7db9bb075eafbb5add50893954c5edd44330e9c96008ce55362c815759404542372da946d112bb622f6f45bb3731be66ce4e8b1e916be2c611b859d4c5ff851b1c5990624f81862a7f510e8e3a0432fcfae729e6f3a80cc2dc3405c7c0eaf5109015c910734f046b5d38f90045c71702e5ba8f21ce0d4dd5aea67d5e004fc8e2a9311c975660dfe32ac0ded00ec48937a256fe808b4b1855da87aef968f19a40d5acc6d3e0846d4955cc98be180b688702c9d5be7eb4992f983b3dbde6f76549ae607e5fc9cd19e0538ed703126f83a20a4e0ffed62e822879724de578100f5703f4011aa65e6910088ebeed477539e47bf74400a12d1f283ca3f1bdd6cce85942f876e8bbff6740301352d8e778652d5bcfca7c05628439c5819b9e8ea80a7580b790fb4159d3b2824b2faa3d7be40038b839ce21f3aa05e1bcdbedf27bd1934b6025195b3f1b287678fefdb4512b31d5712f3e6fd0f69c8b4b39d12dfb47ab304c77c2e340bb534cd6c2dd038222310d08a766b7c4f92c30f7f95d364ad906fed21329ab6a1bbed98c1d8a4f343093f2fd9a9493f97041d4e6e894b89b6243e8abf5d8ca7e4a51d9b7aa5c4077cb571cfdaec68fe38f47eb0df25d14e83ad002fbbfdb538c01593d361eb3fd6169b412ebe8c3a1f9e4ea6dba88d5fd939c9b80bb8fe3b7d6128e61665f6c0b785d553353ededa7020bc4dd14437e3dc490649fac93901e1f35831893578785ecfa6558bb6522c804f2bcdca70a65c22a32623fb834308d835fbf3e4b60066199f94c2e225fb1e860ea908d928cf35c1a158eb9153bbf4f0945ed9a885e22df6abf312c52636e4b9d617e05dd7ce76b08dfad320a70d48050a1080d0885af636528f09d1e524939c3020dd380d77b7901344b96adb4f9ea1b3d41226bcd2ebc3e9a60dfe303beaa1bb4ea2fdc4c90f67269e4cba7e0cccf0919b47aac66ab2e206fdbf5c0e03b355076fae35a790be6fd2331d058728400220184764803eb2a183957262d035302a128c4320b151be2367c75f40f3c601a71e053f443c223480e8e3121b08f4687fa4a0566c14d7c1ede032f42f5bfd0356d6ae8471927d339622b7aabcd70589883311693cffada0b6b187dd5031d7d4515056001ccf68f52cd78c7fb77e2ded9041609a8e3f6355642a67a493021a9764a024e27d9cad3cefd84ec4d8e7122f32fc272acd7541d65d915320447d4a20dff99a3e7e27b31d1deaef00bcc5fff6f0f67f84b425346b78661e45957878dbe0e69927b1bb36aaba97fa2068e2f437cc42d7083989d01a9a98d8b38eb929542c4b390116b58adefade03ace08eb3fceaa018946ec319f75c02b1924cb20221cf0215d392f51bfef8760e2192dc3ab73f77984f054628dabfe0af15bdaab321c7d077d1e69d22ad51acefd5286f165d16b68feee61c8365e4f4deadc16a86fcd630777ca8ff439f10220018f30cf16897cfe5cd6448623b610f68f6c0d0fc99a3650337e3fe5ddfcdd37d7c81fb51f9cfc09f3de324a6666636bd53ea934e2ef92da49725e345ad86f4737b704b771b838700b5a0447ba3e6748e1462b3d5cd244e52e67913d9b6a4ef08121ee65d90076b5526ac8eba4a74345fcf511857576665f4e5d6fdd56e6695c8bff64a1c7db4c752ed39a5428658a60c425e2ac7c8ca8585f9fb2cae4e483bdbb6b490c54370e0f863de49e6d334f0a381049d14240b8343827e3d838e6b13a09ae8f2ee6b348a365e8cb82deeaec44c6cddf3a6e3ed01582dc5559c10c281e7164e166a0b2365e35095582c7bb5363b5477197632448eb11f7ecffee5d176e4f40a65e416318aa0ccce72e384baeac727bcffe8d78c62e4c90588ddea8ecbeba6d1069c3c0a848d9c787b45de503ff9d7c764b35f4c45481da92158de969ea147a422c10a29e7bc0d81e425b70bf4d9c32f5a1ba54fcb93688c5993a74ae5f55f691c32af41bb737a496255886f6ecd014b0a920fc8b1e9e702884b73a328bf9751bcc911181929ad0200431363b3ce4fed4cb2fbb69fdfaf8e28256fa268487b9f2e8b566ba06d6897d2ed402248e3a0fd5ea6964a36979bca2f41f0a15af1bed600e334699d545527c62dc33c9a322147d8e602c6acbb0bf49ebd77b278432fa3c1449133e5d8861ff28ded55872fe771ffdc51a3e15316f50d79b864a423180d851cee3f17b0ba9f85bdcc3d761bb097b9e93e09bb43402109593cb2e58cc59d6f8124b87e00cb847d4b090e07560f02bd4c0a7bcf4132e1b442037f8962312233f9fd20bb1b14af3b4ad0ded27b7e80ddc0a3034c7361891c38f4154fbf21159ce1be0da35f469efec7052257db98535b44286d0c207b6759c65b52287fdd039d076fb2609d41d13d60286668d2bb42b836e0808de3c21b3fc312f072e24de935025b0f3f6b5b2f0f3dceb718417aac30b24de29332dcad8da4134b52d22e7e69e9b3ac9b3068b7bc764a3aa4d9be4dce7a924c95edc020d01a013802c86de5a962e8deeb0e9f833d29d13beb918155ec61dfc828029c87cf1711dea040f57a781013978836d679567ad4ef9da8d878dfc071a06d6a71f24d7301f20dbb81ed418a48a058e894606ad9d9daa6b76eadc240ea99f8c85b23b383ebc84d00750513eeba4e78e44c517adbd6c12fe23c3aed9561a3b7c997a9599d2778ce5cfa88e2e9d6251c616696d65fb29d593e2a20c73d8e323e0f5dc7976ebfc543912e0fb3ec20c5031db35cd3af4ec9eef70ab652d90dc3698e0d3e413a0565ffc850bbe72e75b30ab403616fc558e5d3486cdbaf63337b4c7b6c54f2497981cbe1970e9bb1252750eb393a214289ee83f22a33dea636eb1bb551bc0d593298b32eb2045459d5dd5cbb64f02749d373c21d1c855ad0969f8807f3f0fac27671a7b372b38325ae3b52928a553563847bfa0a1ea8b87fae875435eae06ffff9869c90a4e5020dd6378877657650bc1efa09b2afdf1da3f49a0b31cd6768d05cc7580a99f46f068f7a05d9bdece3af081a0eb202de35d368866f5d330b8ebf14ed609b9db4c4612d70f70ddaa551d6c3c95ed30635d8e973f919f9d7e762da7d989b84232ceb464f223a7193b6c276540bcb86469a11843aa71ca8aa5df865ac6b74c91490182145c178c3e9e5a7d64c474b72607d0350528a72d622f76d57b43f1b12e9ed8c70dd44207ae0d2bfd2cfcf835e0d45e20f8270d4ee75e792771a056806eebd10fb787e6a09a099d3ed091ecbbfe70c4ae9e6ee3372ff5d62476f54b984f0616982fd853b7777475a670300ac43a108152b8c592371bd7617093d971623d19eb619cbd791ba2fb051c4afc2af4b24a377fd3d73507fd2b4aa88990060db54ba70b9d15c63918d6c6ca6a4d3b763a37adb11a636439745aee1b3d1dbfaa39cdf91effc82b43f8110cd1147ca044d9f95930395ce26d2bf16c72ca84159e361e093e9fff28465ab04b4a903ae9d23595338cf52558b35206db6e37c0c1fc5f1ed74f5d263a658fcecaf854bdd80c2877bf3c6ebc741e7d53e79c3ff822fe92494370d3d7aaf7df0cfa3d3e23f461634ba6a05a3351aa54b06f219f5f5f425c8afd26172919258c0384d5b2143abb5866502ac0925e809ae36e3db719a5aa74534d98cd41620f0704b9a1f82c3c9e001d149a4546de3e0406c9cf30fe0e39c8ce8417d24d9dd4a2d02431a7bddac49d67d0b42dfc021c33c01d91ef8fb378da1aee779e283d9cbb314cf93d4c9648c9aa8b84cf898cb450e26ccede9e3de7ed59182b3e1ba436c9e01636440a9ed69a1750e297f16f20389581080564f165856d2dadf30bda8a6ccbf61f98b918b6213140ae586ffcdaacfa95557e747898ecf7af8858858a9051aba631c9803d055770ebc23216655f0d2e0017c8d2db925a736eb6b899d35d8949a2e719e08dfb84e88eb1acb7007c1930560be63ab924730e3fbd9cd605519ff2bec1cf15d1ccf5ab96231a8fa4e582f802b944b1cdad7d4446eb2dccd3f82ff2e16fcd2585a42f28dbf457d1acb0da479b3c84bfb1d899d85b1cb6c954dad088e0cb2715f02cb204c5d29e682349a96521487c807df295a586e1ec66ec1d7a68da2a37fea465201fb6813cb1cda0c9b610cdf2010246473682a92ac190cdb0b607f118a97390166ce9f19650ba6e14decf3f627e9b8782546b681c5ec0b0ebddc961afd13544999c119cda48d5f9c4e3e763176c6b65cdc91f48211397381e4078780c9a3b501678673510dc6c5980182baaeaa8e37321916bab1f9e4b32df125df0fa389c8711d8bd6afe6f128bb89bf9b77628dc76f86ea1c9b53b5734e125e66434eb10591a2f3706b5fdb112c5a810e83fb5be12f97bf56375cd00ac9c1bf7d3e30c9d4e65402505fb5697f7ba8b0995dc6e40fb3e2f83949d0e00160557086b5f45e8f513153beacf56dce781bd05373307746cda5b1705abfc8e7a3dcc9424f38b9089138e17fb7d781d0e30a6957a7cc9f6f261de92b32c3b9e793e611c31c974ab1afede6e040734a1aad5e4ce9a55f726c1c4a7e425669737c101107d13407b77456f97da83ec279c52768bccc1a55cfe73964bb32b04b78c0f288892d128ca570a5e2fbfaf930fd63b0f3db2c3ed99823a1a791fa1b6b35d0ff53c9c60f3d1652258aa83cc21859dc6d81dffe9ba800997d81b46d567285c39a11181272184546e0252a5a8d0faae069c7ceca068bac24c2addf6220a11f16b93778f45db80182d2278959cdedfc9dd633f0a0d7ca66eb8f36284e4713cf7a0e4d51bab787523acdd9f86e1d49e547c686e33a8ff2fe519786c2237fe0bbb8b94c6e5f1a26e45b59f4a15dce889c1427435d6d520504e335e81e4d5c30423d70ff291da1b86bd7173384707d55f063bd135c7f6b8cebd207bfc917ae274f3096202b87e7bc34c916c67d3e7b33372ce711c53ff8889336873384183e3b189940ade45948889f215148704f2f962588a8dc9a35516f43ddd445ba390e093bc9bba45e45f7195473fc4c5fdba9552e07557fa99e751c7a9985293e182c1bf113e5383f6a106d97982c9fb6fba38aae31dd99cdaae55e8cf42daf349960dc395661919a7411994fd9cb4e0dc2335db63f6ecc194cd38e2d0c63dda2088f9c1e513abc1330fe24d2e0c8a43b35dd4ed2e58d892b509f0a3b85906061cc85ea8cd20a4fcbc34fa0b995b90a3842f20d6d5094e62a91dd34c776e2f7cfcf0bdced8c3468a165667c60b33592324f34316a16be6f77183a694155466b52ff74f724e11f61a647056875c13fcd2be3a436bd4534889035ef1b79d6c51955177424dca75e9da6ab4d6d04d122353bf507248fc4f831d92570aedd73ef6e2e53e5f6d1075b9f5ebd3dcb2298f75f2a073dd58c99ef180c067090326351cd92c614805e1b8369eecc44650e2268f128f312937b77a3fdced433d6f95d3e0020ed21f47f97544fb7d233321cb19203ab3846152b78b59e9e5f3947685b5a259b9a1ce4adeb4398872175e8510763e8db851a74ad0a2ec5c3b621bfe69e21bada8e0120ca687f30cb701cd36830c58a37b3aef16f39aac988e52350885c1edda443c2d00c0a91f326fd92b8240bad1df46285fae45782e6bb2395dc959571114c53761a28c340934e88c9f7981ffc1e128d3eb28e24b52710b1b832386d9b942e8a7c1920254925812b554e4cd1babb588488ca5fed66688054ce8de9365fc61f9674f62faee901531127fe76a206f7fd5f7be631598d6403c724894f70dc882e07507ce47dbb1bb4d2c54f1c6413565640382b0d18678adf9ef68dcfed29ce11623b0d5b11fd447f41f92c7523b1e9f2c0b5668a41cdd18e5cb58adabe017e0b1492eafdc3bd2940a0eb8e8a9daf12e5d56babca02fd03debc8c1e5f39e1d570a6813e6f17ac435286bb49fb677b452982792d1cbab83538c3549d03fdec40d00cef31bcd84b57e55b7d2015bf6e443e83afbe8d6db794c2d6bdd27ab03ccf4321d318b37375023ceb9b2c37f6066c0cf626cf058d5d8b494660ad3163a4d2eb0233d6e5fa1a054d4a8eda11e76d9fe4a70e81da9574d0097284c179b42cc79d1e2ad2447a8f22350e17b355ff6ba6fb019eea7f425b9214d4dd1b3efda15eedeca8b5ccfa55ce92a61b82b92241102f643bca5abc42cb9e2145d85df7d53e4f7a5970779196e3098b51223c211d5d8af163f524f693429ef6fdefb2354108d6c1582252eb84c932d1e2f2fbb2e9927205446eb5544eb846c3514cc28ab1610bd29603799d3c9fdd011fe9556edcf7cbda610b365e7524fb0d359d34c677962ae38420ca1a90cb1421aba2908e2afc3acee2ce525efac7e816555311fdb6b0f58fd08cf767dc2fe8713e065c1bf59b05779e3a30ed2eb5519d8d4a72b5047b767de0a51b0da0c5ae22a5d301ba72ee79cb92cb3342e166e87df2717957ec428b554b240690b063390dd36303da35d91555d79f138600412c97d8643714aef36f52eb2d9460a0ec355ceeebd8206d62530ddb2d6488b1beab089422739f2360db65ffc26f900991607c82f647a4f097f09f89899717c00365fadc0abf94ca551b97a529dccdbd77b383b2264f2c189cc82bd6fedba606580937dd9302f4074201bf8bea9bd5141f82735ac2f3c6df5fdcf416d4f0910c70b6f9ca39354bbb4f469f582de494c7378d18b819e41aab6101f8efb1792e94e6f8a193074d251a081679c16d9201c092a0dd61f1af4dd6727fcf6f5433dcb9cd58e68099248fe7aa436f83609b7e070dc279afc8f5da23139886a7e47d20569c092b255b6f7f79c6ab12617632af04bf36a6276472252d3e6367d9a645f9a1aaf52223c745eb930605fe463d6483dadd720ea085b92795f01a40d5fa29ddc548084c4a551db7f606521c039422d8e125afa15c74a0218c364813229a8d8ebd0d6b8135fc498e2f7d86b7e2e914477fcdc7fd4ef6e0427a6455f2d69d64dce3ff1e41b16f93addd54ca03878b31dbe93a80aee1acd93848664923385da221edb3fe37d9955f74f2a8e872fed17613b57301a0280090f7abaa19afdd08687b69e493a1cbb3b50244f98e8ae6b71ab67cbb90ae911fe02c77de08ced9a1f28e0d20931360704c6c34efc095d9b709057df51fc63b2d9bb374966d56d178052f7a6c23067fdf128e0f5d86833d09230a9ee15db6f2d1cda406ac2a0a75adf7832eb74de9e3cd76736b17097812ebc290f9811fabc7d12a5034d20b25ea7b12cd335b018c1ffdd1ce210370a596978bfba66b990b22113a43b3c019b5fd4a1f3ae59a7b49e7da73a3d3d99c37875422e1c91190f29313b956d5aee33eac489e3a2bc8d9c19ff9940f7bad42065ac46ca3bf7d68f22dbb1cc27a04081969683aa35ba54557d949e74e3f9d33508313d3e68cdf17696462af406f3f37fee9f22f399a3bd0707fa2faf3b4105f38a4cfd701dd3d3275778614c5269dae46b7334c424d60afa246b01e6ae9fffa38121587d5a7fe01da9d1192987a417c0fb0e5aab53c6bc11847d34e0bcd74fefbe01db911f75918b2b6c3dbb07217c3228a3dc3ec3d951ce87d239572a20ba09ddb2561ba11d67337f484736f6336a8a1bbe549f207c3cf5adc10a2ba14100773884a1a979a114406134f807ce91ffa40f0a113be6f60b936a94cc30a3a07c7fb0e5c45308280e268a2e400dcdddce1ab75aa42b454439c6cb86402c8b94285044591fc13aaed3c58aa68d41f44a7b5fd444c423f94e68cb0a2b4cc76c5090aa9b2c51932585ebcd8cc71dd5dfdb649557a420d670e2a0ce35ac3bc5e098daf0cab9f82f118fd273ab302e11cadebed0f4dee3326db46b2e9180e78c681ef7fadc55bdc0ec5466c9e76636202561ba5834692eaa82c6cb004a59f16079357175467e01a844b03c9731f299f51ddd7a4309737fb4f75ccf01376b7078947bd0b37e41d8fd149d3357797e4edeb37bda4b48ca34253905f29a956d6470701cbbb04deb8dc059da82e1ef38733c21f3439236092bca722c303ae4197515331c109fc048c41179da7894f8ab95e44066ee40c56a70113bf4673727ac92529dca0f54f8533c9e58441499379e6d38430753a95970f5c2afb38760f555b504c04cbc0a011df263f7c68aaaf80390616b904791d913eef70908008fe414789571b14765608da6c2592712950998e590d7343bf1b5a98a72861f1f402377759a4d09435369c6838a71e3d7b6dde9bd6a56b4bb9924f55b2d5a7d89ec7541f84288cd85e616304966633e06a9ba6ec164aa00f482275cd59a0cffcbbd299d1e9105df882105fc52a2e947e17d97c9dcb3f3d4aaf9e78d2b52b2e2adee113774d4b15c45290d06a121d9efcff052e193fb22e4079554a7babb0300fc16b1cb3ba255c8f30e54282770fdc57286b723421f8682111ecee0b78bf7bcdd8e8b4759c19c94fa5ce12b0f51bce2fc9e0c66892e0f18c877209681d47ddf4d7d489c8d4e8a286c9788ee2dc94ec630202d983427b9a749518e0cf83822df01ef350fc05ff6c035f25f62fc1844b02ea14d945d4420a426b0eda6ccae62b577bd5a9d68e00fc87b760b49b8d4c42c5709337677b6e49bc5fd194151f8f1a9ea4c44775cda699e0ff2fe7d0fcc08fbe14b5bf134f8893f6b8869965b6f27186ef48c8f674de7887acb787b26b0c859a18ce31253764f3443a29b754001cd7162db3e8be184bf2206da590cc80ef1c8f88762a088f4dc758194624baf804724762dace73d419f39403917695a2fe20d1d00462f5f93bb1357c1ef13b5da96c5c4c1c4dda779d78cd4093090cc340df5b5d60e992924e644ae073473bbcabee6580c811e21b95ae989c3a4b5d495d7015faf34df036094bf57d100bdbace4aa2e5f3225055cadbcb41364ac5e404f855cc8384c0c57a6647ff9ed987c01725f59b7420cd22e06b54191c2b9c957565cffa7e9a3aea4f73a57f4fd554430fa12538e56eefded0791fa1810ce5ce11b3eed3c3b89c833dab08481c64d4e201ae5f0c1d4aed76f9713c8bf4a318ab8daffd4f3a7aead364c62e867cec3d8786d80b822ca325110b570c9209650e914f94a0e8f3191d96844983a80e28f3334882b952350bd73e0b29b8c3759d6b5334c8c34ec923283209e008b694cbd3997be90b4cf73cf05d4f494697496aafa1044f4311154cb610fc1d236416a8328e3c2496e1fc30b8ac844a3a96aef3e8efd8d495e67f1476d262ee56134b5cc044c3702d1558af889c6a47196f5e7deb0044f9c25555b97ea8d026d0bdf7576976f3638725e374c635df935f09ce08476d60f2f07e568b752b5f5eb4822560b1884fe46d3bfca1f7e1f3132b3b8a05e5f1ed87c6a9c727abaf7157b9f38aad729f0172acf6e8f41f56de745ba512afa8cdbd3731dc44e8ebc9d06f3c3d9adb2e9901062d7c1890c6fae722be2c7a3aff1cbd002d7069fa987a4c685f52badbf69e41c44886e3ae9bd7a55b64800fded837bfc819d63258a1c1935a06b9c2851e8ae4e6eb2caa7964859b22296981ab330f5b0b631ff4398d664944cd1a3fe25faf7cc5c4cce092dab8e89653a7eaad31bb18e625571ad20407a2c7e6c0bc19c82fb404f25024457012c88970240a014cded26e5d53dc4e2bffe7dd9bd1ea5990d9e16911ce1c1168189dd44b7fdb47ba5d05d29c17d69f0f2cce946e7913d823ad97b22e35392c4f01b7397b274e72482cc3a87c611c47cc117b01a8c94f121a4827e66b22787e537bc9236577a90143d49cd48998dce7336f1be47861e880fe521dac39536d86266b7b67af2d31edf04ae275e724de2764c65d340c06ebb947f8c8f0950be054e5325adde0d3a15fd9d492c25f9f65c0238bf9349a2365cb54fcb1d0d730afc204fa478f0f83cc9119e6562bfe8557935bc9414bec3f858d3457a52dc9692cd44383c93ee750c24c7d62edd57018dc05c7c873e766f8b1824bb371d816f9b12d95479447b5e86ea12ff16f852690b27fdbcdad8ab8915958eada771651f8f3d1bad74c3eb95c6f7d1b5c8e1d93eed367390ef2f9b9ae1202e5b570036a6c0e525e12e17fbf881ad028a5fbb923e87645929411e19c82f5079a571ce38d1ba0d52922774376cdac429d8813e431e23435fa309776ebe01fce28e3e5c76c18047e3bf9daa86c4a4d0cb684f756de0f9abef8648c1f2f919885073c6d5594e71a24bd09a666a2cf348d9511915e7ae43293f7662b1e88b955ee765e5d3d65c5812ad83c881f3cba4c32d90c9a149061207b8c5ea87535b9254ab56a5dbfb0762c53759e92b81075565e8bfc8a8c45ef62c5d3175e80ccb80954f0337e4ff7c9e858d9d083e1e383e46b90aecd79166cd26ed2e94f86bcec33a828a530de6228a9ca5679aed6dbfe049a8b521b2cff72a5699a350f505619c34bab6cb46ae004724ef9019b4941310165f8615f8f73a9cb87725bb0a5c927dc680172bef30a151bc87f26bede5248715f4d6f200d883bb74655a7f317afa2f23ccf6301dadd3197a56398b89aee5fb1e353a4c287cf6a7a2f7c9c2076db0ad559a8027eea17ae9bbe5d65611eaaac5d50c66cbc2e218497640489c4459751984b70321b7e19c5ab28098a966bf8fbf36362f2f8b336467fc5f084546f8905d09cad1c492acc4c8cd8effeb23ea5b7e064222debf5160a17a2639e2e3f09f77699f39ab00ce0966ce29df7bc7d9066f5bbc89aee401cf5f078dc7153d8e1928b80787da07a8fc76d49bd3031e0a8c2eb606188e2bc46da029a3ed98328cb3a31f9efd72133a76757b9da5e3fbbe44520bfde16920c5e673f73dd81ccf7eaff90c74c453c7cdcca1bb9c5b56609418d2aa42e185bc4602306d554653113fcec03e310feb4ec1fbe0d45952f5d2f374d89c9072a4cf81512e36549c80679f48e37a2de82dc959e28eb40af239822e455db1e3d9d78e8811bb9ad6c706538afa7ab4e7062bf30fb5a6b37818260b7cb12291e9aece41e51694aca4cbb0d4e8979c388983a66dda66809c5f4c8e167307c0207da256f7418f931f6f56321a2a3c8f8baa4cc56446c3548fc5f985da1341ca3344ebb12d3dbb5b7975a8817c4da468f268d5fc86cca992518d5e6e1a277dce26c4926d577c82c2e870b341bc632e8abe68f447bf47b47f3cb430f3e517aa469c95af902db133ab43ee077db58e18adeb087115ccf520f861ce118c62f923d229c7468dc5c0976f72bd07379aed21d9970a80a74756eb512d0c2745f5632d4132e7d013e0b8332b7b09c177c6bdceed257e08905945f3f11b36dc1462e866fe471e929b79d7dc628348a28f5d82c2e1371d7083fa3458b6d8d0c088487a8e23bcb701dddf20be8aec23fc43532def3d9581bf32525df228fecb8873aacf6f925df5c55e78cab020ae5a853e7bf0eb866c4d01b60d7f716f92fc167e640fad8bca8e3625c9f8931b56c7dd939a6c9f3691a3573dfb5956be434442a83d83d7436677235fefe795852701d53077ad7c5ac7fdf1afc7284ca5a2a69d04c692654865c399d0f41749be9022543f37e7269021be55f5e6db2c7d71c076f7a4a5fefec0c0a7517416c01ba9e892ea7194db7fef61e2cb30414f1df130d41709978fa13f945714c35c2f83fb8902fb8b8c030b65f911e1a109fac7f0995aeaa22bb6587e33fd328c159311c4f9f66ec5a6611e95c7534ba0b0fdb71079ce6dc3cc394f6e1a6b6fe90d2823ec9bdeb0b5824ec8904b7d87dafa6027980172e8a77222a5d3b05639f783cfd3e987bdb00788defa864d587db7c31b6e4bff1a17168cc40b2398a3110af53251cd0d30828e40d9e2bafc042685cb10a79464c839253757b21b2bb038420ef214ee2feec6673b147b3e933000a94692deae5d2a7d78e459e282f8fa2e61f41cc46ce87704ef740c01df69ab9a012a6ccab39ebe33928971795c59c6f063065223957f8c58a6774cdf82a949cf938e7f37b696d5856f7005048a08f03618e06b025158fcc8a0b6ae3fed21d2ebef62a37e2c19789a714324d7b2f2a2843cce3ac855b28bb8a9a7f46f44f327dae8de4e13a9b318e60b1f32dad4ec551a67ad16b87ea76f328815fc79ac43214363b59f43ca09508c21d5ead71fe5d9643a7c01d0150ac45cb71fd423f53698af24ae6b49db02dd51623a6b75f0e9935703d43017d74c75f218e4eb8dfffa2081ca0eb1d27b99c1011204350dce4e8485ad230b78f97de1bdf8a7222a96da91e26328d89afab3db4ac252830f44ae1a43f6e85a840efac3ef59bc86c86b79dc434d26efc3a29f9f093bd079c519eee82a7e7f32c67913487d334b6625026b4f546a091c824826942234126768d306eec03d63be5b937000818e1d6d08979858d11321ae113ceff19b630f4b8e08d7699e6e04761f306293623a5a510ff9a41305b52755382e80218621eccebc1e38755a8ae52e744d2a3b2c80da8b4f073e0c914bed4589f2d1060c7f294dc6cbd4ebceaf56833ac90047a76014fb1c4007b8d77abc3f87f1899c7ce2496cb52d8eaf31d12f24f9d55fb74269b552ef0b843d2ab742792578d76f0adccfd0a2ac83cbb66c911db85c6c526ea03648e3bd4b96ad943851b057cb7e11986d320db142ebc452e0f443a57593e18c4843f1ede6d0eb3c97ff08966f061f9ba1a74f00f0ee9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>course</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java和算法</title>
    <url>/2023/05/04/20230504/</url>
    <content><![CDATA[<p>纯试手写第一篇文章</p>
<span id="more"></span>

<h3 id="上午写java实验——内部类和自定义类实验"><a href="#上午写java实验——内部类和自定义类实验" class="headerlink" title="上午写java实验——内部类和自定义类实验"></a>上午写java实验——内部类和自定义类实验</h3><p>注意到了一个细节，try范围内的代码是只要有异常抛出，就不会执行下去了，直接跳转到catch，后面也不会跳回去，除非有while循环，才可以循环执行try范围内的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    reald = Double.parseDouble(real);</span><br><span class="line">    virtuald = Double.parseDouble(virtual);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;格式不对，请重新输入:&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码如果 real 转换成 reald ，那么直接跳转到第一个 catch ，之后的 virtual 转换成 virtuald 和  break 不会发生。</p>
<p>如果需要无条件执行一些代码，则需要使用关键字 finally。例如下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    reald = Double.parseDouble(real);</span><br><span class="line">    virtuald = Double.parseDouble(virtual);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;格式不对，请重新输入:&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码若输入 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ff</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>即将 ff 和 1 转型为 double 类型，显然，ff 不能转型为 double 类型，因此捕获异常，直接跳转到第 6 行，其中第 4 行的 break 并不会执行，但是第 10 行的 println 确执行了。</p>
<h6 id="finally-关键字只有在退出虚拟机的时候才会被中断，否则不会中断。"><a href="#finally-关键字只有在退出虚拟机的时候才会被中断，否则不会中断。" class="headerlink" title="finally 关键字只有在退出虚拟机的时候才会被中断，否则不会中断。"></a>finally 关键字只有在退出虚拟机的时候才会被中断，否则不会中断。</h6><p>执行代码结果如下图</p>
<p><img src="/2023/05/04/20230504/20230504_01.jpg" alt="20230504_01"></p>
<h3 id="算法设计与分析作业-3"><a href="#算法设计与分析作业-3" class="headerlink" title="算法设计与分析作业  3"></a>算法设计与分析作业  3</h3><p>晚上写了一下 算法设计与分析作业 3</p>
<p>求最长不下降序列的代码</p>
<p>例如：</p>
<p>在以下数组中，求最长不下降序列。其结果就是  1，2，6，9</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">6</span>，<span class="number">4</span>，<span class="number">9</span>，<span class="number">-9</span>，<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果只有一个数字，那么最长不下降序列就是它本身，即记第一个元素为1（即在dp数组的对应位置中记为1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果接下来的元素值比前一个元素大，且dp值小于或等于前一个元素的dp值+1，那么这个元素的dp值+1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//因为2&gt;1且2的dp值（也就是1）等于1的dp值，所以2的dp值可以+1</span></span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//以此类推</span></span><br><span class="line">dp[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//第三个数字是6，</span></span><br><span class="line">dp[<span class="number">4</span>] = <span class="number">3</span>;<span class="comment">//因为6&lt;4,只能从2的dp上+1</span></span><br><span class="line">dp[<span class="number">5</span>] = <span class="number">4</span>;<span class="comment">//不论从6的dp值算还是从4的dp值算，都是4</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//以此类推</span></span><br></pre></td></tr></table></figure>

<p>具体代码实现如下（cout出来的只是一个数字，可以修改，但是核心思想相同）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[MAX_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dp[MAX_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= arr[j] &amp;&amp; (dp[j] + <span class="number">1</span>) &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>What I did today</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
